<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.6" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png?v=6.0.6">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png?v=6.0.6">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png?v=6.0.6">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.6" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.0.6',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="Hexo, NexT" />


<meta name="description" content="好想去看dac">
<meta property="og:type" content="website">
<meta property="og:title" content="clunyes_blog">
<meta property="og:url" content="http://clunyes.github.io/page/2/index.html">
<meta property="og:site_name" content="clunyes_blog">
<meta property="og:description" content="好想去看dac">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="clunyes_blog">
<meta name="twitter:description" content="好想去看dac">






  <link rel="canonical" href="http://clunyes.github.io/page/2/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>clunyes_blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> 

<div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">clunyes_blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        
          
  <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
</li>

      
        
        
          
  <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />About</a>
</li>

      
        
        
          
  <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
</li>

      

      
    </ul>
  

  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/02/28/java深入学习/java线程池/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/28/java深入学习/java线程池/" itemprop="url">java线程池</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-28T17:27:56+08:00">2017-02-28</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先要理清几个类</p>
<pre><code>Executor 接口，只有一个抽象方法，执行runnable任务。

ExecutorService 接口，继承自Executor，添加了一些生命周期管理的方法。
Executor的生命周期有三种状态，运行 ，关闭 ，终止。Executor创建时处于运行状态。
当调用ExecutorService.shutdown()后，处于关闭状态，isShutdown()方法返回true。
这时，不应该再想Executor中添加任务，所有已添加的任务执行完毕后，Executor处于终止状态，isTerminated()返回true。
如果Executor处于关闭状态，往Executor提交任务会抛出unchecked exception RejectedExecutionException。

AbstractExecutorService 抽象类，实现了ExecutorService

ThreadPoolExecutor 实现类，继承自AbstractExecutorService
</code></pre><p>可返回值的任务必须实现Callable接口，类似的，无返回值的任务必须Runnable接口。    </p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/02/28/设计模式/创建型/Builder模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/28/设计模式/创建型/Builder模式/" itemprop="url">Builder模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-28T16:03:40+08:00">2017-02-28</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##Builder模式</p>
<pre><code>典型的builder，android的dialog
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/02/28/java深入学习/LinkedList解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/28/java深入学习/LinkedList解析/" itemprop="url">LinkedList解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-28T14:52:48+08:00">2017-02-28</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>LinkedList与ArrayList一样实现List接口，只是ArrayList是List接口的大小可变数组的实现，<br>LinkedList是List接口链表的实现。基于链表实现的方式使得LinkedList在插入和删除时更优于ArrayList，<br>而随机访问则比ArrayList逊色些。</p>
<p><img src="/2017/02/28/java深入学习/LinkedList解析/../../../../images/linkedlist/singleLink.jpg" alt=""></p>
<p><img src="/2017/02/28/java深入学习/LinkedList解析/../../../../images/linkedlist/singleLoopLink.jpg" alt=""></p>
<p><img src="/2017/02/28/java深入学习/LinkedList解析/../../../../images/linkedlist/doubleLink.jpg" alt=""></p>
<p><img src="/2017/02/28/java深入学习/LinkedList解析/../../../../images/linkedlist/doubleLoopLink.jpg" alt=""></p>
<p>LinkedList 是一个双向循环链表</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/02/28/java深入学习/ArrayList解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/28/java深入学习/ArrayList解析/" itemprop="url">ArrayList解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-28T14:13:40+08:00">2017-02-28</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ArrayList 是一个数组队列，相当于动态数组。</p>
<p>难点</p>
<p><img src="/2017/02/28/java深入学习/ArrayList解析/../../../../images/listadd.jpg" alt=""></p>
<p><img src="/2017/02/28/java深入学习/ArrayList解析/../../../../images/listinsert.jpg" alt=""></p>
<p>总结<br>ArrayList和LinkedList的区别</p>
<pre><code>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。
对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。
对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。
</code></pre><p>ArrayList和Vector的区别</p>
<pre><code>Vector和ArrayList几乎是完全相同的,唯一的区别在于Vector是同步类(synchronized)，属于强同步类。因此开销就比ArrayList要大，访问要慢。正常情况下,大多数的Java程序员使用ArrayList而不是Vector,因为同步完全可以由程序员自己来控制。
Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。
Vector还有一个子类Stack.
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/02/28/java深入学习/java集合理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/28/java深入学习/java集合理解/" itemprop="url">java集合理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-28T11:13:26+08:00">2017-02-28</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>近来面试，屡屡被数据结构算法所虐。</p>
<p>所以最近在恶补这方面的知识，想想以前在学校还是too young too simple，要是有老师傅带带我该多好。<br>老师我错了，我真的好想再打Dota，哦不，再学数据结构算法。</p>
<p>Java集合是java提供的工具包，包含了常用的数据结构：集合、链表、队列、栈、数组、映射等。</p>
<p>接下来梳理一下</p>
<pre><code>最主要的接口Collection接口，map接口

Collection接口

    是List、Set和Queue接口的父接口
    定义了可用于操作List、Set和Queue的方法-增删改查

List接口

    List是元素有序并且可以重复的集合，被称为序列
    List可以精确的控制每个元素的插入位置，或删除某个位置元素
    List接口的常用子类：
    ArrayList 
    LinkedList 
    Vector
    Stack

Set接口

    Set接口中不能加入重复元素，无序
    Set接口常用子类：
    散列存放：HashSet
    有序存放：TreeSet

Map和HashMap

Map接口

    Map提供了一种映射关系，其中的元素是以键值对（key-value）的形式存储的，能够实现根据key快速查找value
    Map中的键值对以Entry类型的对象实例形式存在
    键（key值）不可重复，value值可以
    每个建最多只能映射到一个值
    Map接口提供了分别返回key值集合、value值集合以及Entry（键值对）集合的方法
    Map支持泛型，形式如：Map&lt;K,V&gt;

HashMap类

    HashMap是Map的一个重要实现类，也是最常用，基于哈希表实现
    HashMap中的Entry对象是无序排列的
    Key值和Value值都可以为null,但是一个HashMap只能有一个key值为null的映射（key值不可重复）

Comparable和Comparator

Comparable接口——可比较的

    实现该接口表示：这个类的实例可以比较大小，可以进行自然排序
    定义了默认的比较规则
    其实现类需要实现compareTo()方法
    compareTo()方法返回正数表示大，负数表示小0表示相等

Comparator接口——比较工具接口

    用于定义临时比较规则，而不是默认比较规则
    其实现类需要实现compare()方法
    Comparable和Comparator都是Java集合框架的成员

Iterator接口

    集合输出的标准操作
    标准做法，使用Iterator接口
    操作原理：
    Iterator是专门的迭代输出接口，迭代输出就是将元素一个个进行判断，判断其是否有内容，如果有内容则把内容取出。
</code></pre><p><img src="/2017/02/28/java深入学习/java集合理解/../../../../../images/collections.png" alt="">.</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/02/28/android中的各种位置/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/28/android中的各种位置/" itemprop="url">android中的各种位置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-28T10:57:42+08:00">2017-02-28</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2017/02/28/android中的各种位置/../../../images/androidPosition.png" alt="">.</p>
<pre><code>View提供的获取坐标方法
　　getTop()：获取到的是View自身的顶边到其父布局顶边的距离。
　　getLeft()：获取到的是View自身的左边到其父布局左边的距离。
　　getRight()：获取到的是View自身的右边到其父布局左边的距离。
　　getBottom()：获取到的是View自身的底边到其父布局顶边的距离。
</code></pre><hr>
<pre><code>MotionEvent提供的方法
　　getX()：获取点击事件距离控件左边的距离，即视图坐标。
　　getY()：获取点击事件距离控件顶边的距离，即视图坐标。
　　getRawX()：获取点击事件距离整个屏幕左边的距离，即绝对坐标。
　　getRawY()：获取点击事件距离整个屏幕顶边的距离，即绝对坐标。
　　相信通过上图，读者们应该对MotionEvent和Android坐标系有了一个比较清楚的认识。 
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/02/27/设计模式/创建型/抽象工厂模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/27/设计模式/创建型/抽象工厂模式/" itemprop="url">抽象工厂模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-27T14:28:08+08:00">2017-02-27</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##抽象工厂模式</p>
<p>解决的问题</p>
<pre><code>每个工厂只能创建一类产品
</code></pre><p>伪代码<br>首先我们需要若干种门</p>
<pre><code>interface Door {
    public function getDescription();
}

class WoodenDoor implements Door {
    public function getDescription() {
        echo &apos;I am a wooden door&apos;;
    }
}

class IronDoor implements Door {
    public function getDescription() {
        echo &apos;I am an iron door&apos;;
    }
}
</code></pre><p>首先我们要若干老师傅</p>
<pre><code>interface DoorFittingExpert {
    public function getDescription();
}

class Welder implements DoorFittingExpert {
    public function getDescription() {
        echo &apos;I can only fit iron doors&apos;;
    }
}

class Carpenter implements DoorFittingExpert {
    public function getDescription() {
        echo &apos;I can only fit wooden doors&apos;;
    }
}
</code></pre><p>好了，木门工厂有木门老师傅，铁门工厂有铁门老师傅</p>
<pre><code>interface DoorFactory {
    public function makeDoor() : Door;
    public function makeFittingExpert() : DoorFittingExpert;
}

// Wooden factory to return carpenter and wooden door
class WoodenDoorFactory implements DoorFactory {
    public function makeDoor() : Door {
        return new WoodenDoor();
    }

    public function makeFittingExpert() : DoorFittingExpert{
        return new Carpenter();
    }
}

// Iron door factory to get iron door and the relevant fitting expert
class IronDoorFactory implements DoorFactory {
    public function makeDoor() : Door {
        return new IronDoor();
    }

    public function makeFittingExpert() : DoorFittingExpert{
        return new Welder();
    }
}
</code></pre><p>工厂启动    </p>
<pre><code>$woodenFactory = new WoodenDoorFactory();

$door = $woodenFactory-&gt;makeDoor();
$expert = $woodenFactory-&gt;makeFittingExpert();

$door-&gt;getDescription();  // Output: I am a wooden door
$expert-&gt;getDescription(); // Output: I can only fit wooden doors

// Same for Iron Factory
$ironFactory = new IronDoorFactory();

$door = $ironFactory-&gt;makeDoor();
$expert = $ironFactory-&gt;makeFittingExpert();

$door-&gt;getDescription();  // Output: I am an iron door
$expert-&gt;getDescription(); // Output: I can only fit iron doors
</code></pre><hr>
<p>优点</p>
<pre><code>降低耦合
抽象工厂模式将具体产品的创建延迟到具体工厂的子类中，这样将对象的创建封装起来，可以减少客户端与具体产品类之间的依赖，从而使系统耦合度低，这样更有利于后期的维护和扩展；

更符合开-闭原则
新增一种产品类时，只需要增加相应的具体产品类和相应的工厂子类即可

    简单工厂模式需要修改工厂类的判断逻辑

符合单一职责原则
每个具体工厂类只负责创建对应的产品

    简单工厂中的工厂类存在复杂的switch逻辑判断

不使用静态工厂方法，可以形成基于继承的等级结构。

    简单工厂模式的工厂类使用静态工厂方法
</code></pre><p>缺点</p>
<pre><code>抽象工厂模式很难支持新种类产品的变化。
这是因为抽象工厂接口中已经确定了可以被创建的产品集合，如果需要添加新产品，此时就必须去修改抽象工厂的接口，
这样就涉及到抽象工厂类的以及所有子类的改变，这样也就违背了“开发——封闭”原则。
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/02/27/设计模式/创建型/工厂方法模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/27/设计模式/创建型/工厂方法模式/" itemprop="url">工厂方法模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-27T14:17:09+08:00">2017-02-27</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##工厂方法模式</p>
<p>解决的问题</p>
<pre><code>工厂一旦需要生产新产品就需要修改工厂类的方法逻辑，违背了“开放 - 关闭原则
</code></pre><p>伪代码<br>面试官接口，两个实现</p>
<pre><code>interface Interviewer {
    public function askQuestions();
}

class Developer implements Interviewer {
    public function askQuestions() {
        echo &apos;Asking about design patterns!&apos;;
    }
}

class CommunityExecutive implements Interviewer {
    public function askQuestions() {
        echo &apos;Asking about community building&apos;;
    }
}
</code></pre><p>招聘经理：找个人去面试，然后问问题</p>
<pre><code>abstract class HiringManager {

    // Factory method
    abstract public function makeInterviewer() : Interviewer;

    public function takeInterview() {
        $interviewer = $this-&gt;makeInterviewer();
        $interviewer-&gt;askQuestions();
    }
}
</code></pre><p>开发主管问开发者问题，市场主管问市场问题</p>
<pre><code>class DevelopmentManager extends HiringManager {
    public function makeInterviewer() : Interviewer {
        return new Developer();
    }
}

class MarketingManager extends HiringManager {
    public function makeInterviewer() : Interviewer {
        return new CommunityExecutive();
    }
}
</code></pre><p>投入使用</p>
<pre><code>$devManager = new DevelopmentManager();
$devManager-&gt;takeInterview(); // Output: Asking about design patterns

$marketingManager = new MarketingManager();
$marketingManager-&gt;takeInterview(); // Output: Asking about community building.
</code></pre><hr>
<p>优点</p>
<pre><code>1. 工厂模式可以说是简单工厂模式的进一步抽象和拓展，
在保留了简单工厂的封装优点的同时，让扩展变得简单，让继承变得可行，增加了多态性的体现。
</code></pre><p>缺点</p>
<pre><code>1. 添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；
2. 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。
3. 虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类；
4. 一个具体工厂只能创建一种具体产品
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/02/27/java深入学习/javaThread状态/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/27/java深入学习/javaThread状态/" itemprop="url">javaThread状态</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-27T10:51:02+08:00">2017-02-27</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先一个小问题：线程实现可以是thread和runnable，本身两者并没有优劣，但是一个是继承一个是接口，如果你要继承其他类，还是用runnable。</p>
<p>run和start的区别，start方法开启了新线程，run方法没有，start方法不阻塞主线程。</p>
<p>以下是thread的两张状态图，有助于理解线程的生命周期（哪个顺眼你看哪个）。</p>
<p><img src="/2017/02/27/java深入学习/javaThread状态/../../../../images/threadStatus.jpg" alt=""></p>
<p><img src="/2017/02/27/java深入学习/javaThread状态/../../../../images/threadProcess.jpg" alt=""></p>
<p>两个图有个冲突，即join方法，待验证。</p>
<ol>
<li><p>程序通过Thread t = new Thread()，调用t.start()启动一个线程，使该线程进入可运行(Runnable)的状态。</p>
</li>
<li><p>由JVM的决定去调度(Scheduler) 在可运行状态（Runnable）下的线程,使该线程处于运行 (Running) 状态,<br>由于JVM的调度会出现不可控性，即不是优先级高的先被调用，可能先调用，也可能后调用的的情况。运行状态(Running)下，<br>调用礼让yield()方法，可以使线程回到可运行状态(Runnable)下，再次JVM的调度（并不依赖优先级）。</p>
</li>
<li><p>线程在Running的过程中可能会遇到阻塞(Blocked)情况</p>
</li>
</ol>
<p>①．调用join()和sleep()方法，sleep()时间结束或被打断，join()中断,IO完成都会回到Runnable状态，等待JVM的调度。</p>
<p>②．调用wait()，使该线程处于等待池(wait blocked pool),直到notify()/notifyAll()，线程被唤醒被放到锁池(lock blocked pool )<br>，释放同步锁使线程回到可运行状态（Runnable）</p>
<p>③．对Running状态的线程加同步锁(Synchronized)使其进入(lock blocked pool ),同步锁被释放进入可运行状态(Runnable)。</p>
<ol>
<li>线程run()运行结束或异常退出，线程到达死亡状态(Dead)</li>
</ol>
<p>sleep和wait的区别有：</p>
<pre><code>sleep是Thread类的方法,wait是Object类中定义的方法.

Thread.sleep不会导致锁行为的改变, 如果当前线程是拥有锁的, 那么Thread.sleep不会让线程释放锁.

Thread.sleep和Object.wait都会暂停当前的线程. OS会将执行时间分配给其它线程. 区别是, 调用wait后, 
需要别的线程执行notify/notifyAll才能够重新获得CPU执行时间.
</code></pre><p>sleep不会释放锁，yield同样不会释放锁。</p>
<pre><code>join()方法

在很多情况下，主线程创建并启动了线程，如果子线程中进行大量耗时运算，主线程往往将早于子线程结束之前结束。
这时，如果主线程想等待子线程执行完成之后再结束，比如子线程处理一个数据，主线程要取得这个数据中的值，就要用到join()方法了。
方法join()的作用是等待线程对象销毁。
</code></pre><p>线程的上下文切换：</p>
<pre><code>对于单核CPU来说（对于多核CPU，此处就理解为一个核），CPU在一个时刻只能运行一个线程，
当在运行一个线程的过程中转去运行另外一个线程，这个叫做线程上下文切换（对于进程也是类似）。
实际上就是 存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行。
</code></pre><p>停止线程</p>
<p>停止线程是在多线程开发时很重要的技术点，掌握此技术可以对线程的停止进行有效的处理。<br>停止一个线程可以使用Thread.stop()方法，但最好不用它。该方法是不安全的，已被弃用。<br>在Java中有以下3种方法可以终止正在运行的线程：</p>
<pre><code>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止

使用stop方法强行终止线程，但是不推荐使用这个方法，因为stop和suspend及resume一样，都是作废过期的方法，使用他们可能产生不可预料的结果。

使用interrupt方法中断线程，但这个不会终止一个正在运行的线程，还需要加入一个判断才可以完成线程的停止。
</code></pre><p>暂停线程</p>
<pre><code>interrupt()方法
</code></pre><p>线程的优先级</p>
<pre><code>public final static int MIN_PRIORITY = 1;
public final static int NORM_PRIORITY = 5;
public final static int MAX_PRIORITY = 10;
</code></pre><p>守护线程</p>
<pre><code>在Java线程中有两种线程，一种是User Thread（用户线程），另一种是Daemon Thread(守护线程)。

Daemon的作用是为其他线程的运行提供服务，比如说GC线程。
其实User Thread线程和Daemon Thread守护线程本质上来说去没啥区别的，唯一的区别之处就在虚拟机的离开：
如果User Thread全部撤离，那么Daemon Thread也就没啥线程好服务的了，所以虚拟机也就退出了。
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/02/27/设计模式/创建型/简单工厂/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/27/设计模式/创建型/简单工厂/" itemprop="url">简单工厂</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-27T09:25:58+08:00">2017-02-27</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##简单工厂</p>
<p>解决的问题</p>
<pre><code>即使用者可直接消费产品而不需要知道其生产的细节
</code></pre><p>伪代码<br>创建门接口</p>
<pre><code>interface Door {
    public function getWidth() : float;
    public function getHeight() : float;
}

class WoodenDoor implements Door {
    protected $width;
    protected $height;

    public function __construct(float $width, float $height) {
        $this-&gt;width = $width;
        $this-&gt;height = $height;
    }

    public function getWidth() : float {
        return $this-&gt;width;
    }

    public function getHeight() : float {
        return $this-&gt;height;
    }
}
</code></pre><p>生产门</p>
<pre><code>class DoorFactory {
   public static function makeDoor($width, $height) : Door {
       return new WoodenDoor($width, $height);
   }
}
</code></pre><p>投入使用</p>
<pre><code>$door = DoorFactory::makeDoor(100, 200);
echo &apos;Width: &apos; . $door-&gt;getWidth();
echo &apos;Height: &apos; . $door-&gt;getHeight();
</code></pre><hr>
<p>优点</p>
<pre><code>1. 将创建实例的工作与使用实例的工作分开，使用者不必关心类对象如何创建，实现了解耦；
2. 把初始化实例时的工作放到工厂里进行，使代码更容易维护。 更符合面向对象的原则 &amp; 面向接口编程，而不是面向实现编程。
</code></pre><p>缺点</p>
<pre><code>1. 工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响；
2. 违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。
3. 简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构。
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/02/24/android系统分析/activity启动和service启动/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/24/android系统分析/activity启动和service启动/" itemprop="url">activity启动和service启动</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-24T13:49:03+08:00">2017-02-24</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对于android最重要的两个核心组件activity service研究也是比较多的</p>
<p>浅显的问题1： startService和bindService有什么区别：</p>
<pre><code>startService()方式启动，Service是通过接受Intent并且会经历onCreate()和onStartCommand()。当用户在发出意图使之销毁时会经历onDestroy()。
而bindService()方式启动，与Activity绑定的时候，会经历onCreate()和onBind()，而当Activity被销毁的时候，Service会先调用onUnbind()然后是onDestroy()。

使用startService()方法启用服务，调用者与服务之间没有关连，即使调用者退出了，服务仍然运行。
使用bindService()方法启用服务，调用者与服务绑定在了一起，调用者一旦退出，服务也就终止。
</code></pre><p>深入的问题1:<br>Binder优势：<br>Android需要建立一套新的IPC机制来满足系统对通信方式，传输性能和安全性的要求，这就是Binder。<br><a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="noopener">http://blog.csdn.net/universus/article/details/6211589</a> 这篇文章可以反复阅读。</p>
<pre><code>Binder通信的四个角色：

    Client进程：使用服务的进程。
    Server进程：提供服务的进程。
    ServiceManager进程：ServiceManager的作用是将字符形式的Binder名字转化成Client中对该Binder的引用，使得Client能够通过Binder名字获得对Server中Binder实体的引用。
    Binder驱动：驱动负责进程之间Binder通信的建立，Binder在进程之间的传递，Binder引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。
</code></pre><p>那么他们的启动流程到底是怎么样的？</p>
<p>看到一篇非常好的文章<br>activity启动流程文章： <a href="http://www.jianshu.com/p/e0a6717bc75e" target="_blank" rel="noopener">http://www.jianshu.com/p/e0a6717bc75e</a><br>，我就不献丑了</p>
<p>基本流程-两个ipc，应用进程和system server进程，应用进程里涉及到的线程包括ui线程和ApplicationThread</p>
<pre><code>Activty---ActivityManagerProxy : ActvitiyManagerNative--ActivityManagerService

ActivityManagerService--ApplicationThreadProxy : ApplicationThreadNative--ApplicationThread-(H handler)-ActivityThread
</code></pre><p>service和activity流程基本差不多</p>
<p>我这里介绍下一些关键的类</p>
<pre><code>ActivityManagerService （很多都是简称ams，类似的重要服务还有很多PackageManagerService，WindowManagerService）
相当于BookManagerService，是服务端。

服务端提供哪些接口？IBookManager中说明提供了哪些接口。

ActivityManagerNative
怎么和服务端通信呢，要一个AIDL的接口，这个相当于IBookManager.Stub。

ActivityManagerProxy
具体方法的实现在呢，Proxy就是具体实现了

Instrumentation
工具类
</code></pre><p><a href="http://clunyes.github.io/2017/2/20/android系统分析/AIDL的梳理.md/">具体aidl怎么实现</a>请看这里.    </p>
<p>关于AMS，AMS并不是字面意思Activity管理服务，而是service也在其中管理。</p>
<p>启动Activity至少需要两个前提，第一是，应用进程存在，第二AMS已经初始化完毕。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/02/23/android tip/gradle参数说明/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/23/android tip/gradle参数说明/" itemprop="url">gradle参数说明</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-23T18:08:49+08:00">2017-02-23</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>jumboMode 不知道什么意思，和multiDex有类似的功能</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/02/22/android热修复原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/22/android热修复原理/" itemprop="url">android热修复原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-22T17:42:36+08:00">2017-02-22</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>目前常用的热修复技术</p>
<pre><code>AndFix   采用的是Native hook方案

Nuwa, HotFix, RocooFix  采用的是QQ空间提出的Classloader替换类的方案

Tinker  采用的是Instant Run的冷插拔原理的Dex替换
</code></pre><p>以下一一分析</p>
<pre><code>native hook：  在native层进行指针替换，AndFix基于修复包和原生包的区别，加入注解，
通过这份注解来找到要替换的方法，如果可以就会hook该方法并进行替换。
</code></pre><hr>
<pre><code>Nuwa Hotfix RocooFix这些方案是基于dex分包方案
</code></pre><hr>
<pre><code>什么是dex分包：

当 Android 系统安装一个应用的时候，有一步是对 Dex 进行优化，这个过程有一个专门的工具来处理，叫 DexOpt。DexOpt 
是在第一次加载 Dex 文件的时候执行的。这个过程会生成一个 ODEX 文件，即 Optimised Dex。
执行 ODEX 的效率会比直接执行 Dex 文件的效率要高很多。

但是在早期的 Android 系统中，DexOpt 有两个问题。
（一）：DexOpt 会把每一个类的方法 id 检索起来，存在一个链表结构里面，但是这个链表的长度是用一个 short 类型来保存的，
导致了方法 id 的数目不能够超过65536个。一个dex文件最多只支持65536个方法。
（官方提出了multidex的解决方案）

（二）：Dexopt 使用 LinearAlloc 来存储应用的方法信息。Dalvik LinearAlloc 是一个固定大小的缓冲区。
在Android 版本的历史上，LinearAlloc 分别经历了4M/5M/8M/16M限制。Android 2.2和2.3的缓冲区只有5MB，
Android 4.x提高到了8MB 或16MB。当方法数量过多导致超出缓冲区大小时，也会造成dexopt崩溃。
</code></pre><hr>
<pre><code>由于上述问题的存在，通过不断研究，便有了dex分包的解决方案。
</code></pre><hr>
<pre><code>简单来说，其原理是将编译好的class文件拆分打包成两个dex，绕过dex方法数量的限制以及安装时的检查，在运行时再动态加载第二个dex文件中。
原则上两个dex的类是没有重复的 ，如果classes.dex和classes1.dex中有重复的类，当用到这个重复的类的时候，系统会选择哪个类进行加载呢？
</code></pre><p>理论知识来了：<br>    一个ClassLoader可以包含多个dex文件，每个dex文件是一个Element，多个dex文件排列成一个有序的数组dexElements，<br>当找类的时候，会按顺序遍历dex文件，然后从当前遍历的dex文件中找类，如果找类则返回，如果找不到从下一个dex文件继续查找。</p>
<p>那么，如果有重复的类，以前面的dex为准。把有问题的类打包到一个dex（patch.dex）中去，然后把这个dex插入到Elements的最前面，就能实现热修复了。</p>
<p>理论到此为止。</p>
<hr>
<pre><code>Tinker的原理：Instant Run的冷插拔，完全使用了新的Dex，但是又不能直接替换dex，那么怎么做呢。

在编译时通过新旧两个Dex生成差异patch.dex。在运行时，将差异patch.dex重新跟原始安装包的旧Dex还原为新的Dex。
这里就涉及到怎么最优算patch包的问题。

这套方案有两个缺点：占用更多空间。

一个额外的合成过程；虽然我们单独放在一个进程上处理，但是合成时间的长短与内存消耗也会影响最终的成功率
(与修改Dex大小、补丁大小相关)。
</code></pre><p>但是我觉得这两个缺点都不是问题，毕竟热修复不能当做更新来用。。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/02/20/android系统分析/AIDL的梳理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/20/android系统分析/AIDL的梳理/" itemprop="url">AIDL的梳理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-20T18:06:36+08:00">2017-02-20</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>android IPC 不得不提到AIDL，其余广播 bundle ContentProvider以及socket</p>
<p>其中又以AIDL最为关键（在android中就是这样）。</p>
<p>其中又有一个关键字Binder，在我理解看来Binder是一个桥梁。</p>
<p>下面演示下binder，按照android开发艺术探索的指引，生成IBookManager.java文件</p>
<pre><code>/*
 * This file is auto-generated.  DO NOT MODIFY.
 * Original file: E:\\workspace_study\\ZKTestProject\\app\\src\\main\\aidl\\com\\zhaokang\\zktestproject\\IBookManager.aidl
 */
package com.zhaokang.zktestproject;

public interface IBookManager extends android.os.IInterface {
    /**
     * Local-side IPC implementation stub class.
     */
    public static abstract class Stub extends android.os.Binder implements com.zhaokang.zktestproject.IBookManager {
        private static final java.lang.String DESCRIPTOR = &quot;com.zhaokang.zktestproject.IBookManager&quot;;

        /**
         * Construct the stub at attach it to the interface.
         */
        public Stub() {
            this.attachInterface(this, DESCRIPTOR);
        }

        /**
         * Cast an IBinder object into an com.zhaokang.zktestproject.IBookManager interface,
         * generating a proxy if needed.
         */
        public static com.zhaokang.zktestproject.IBookManager asInterface(android.os.IBinder obj) {
            if ((obj == null)) {
                return null;
            }
            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);
            if (((iin != null) &amp;&amp; (iin instanceof com.zhaokang.zktestproject.IBookManager))) {
                return ((com.zhaokang.zktestproject.IBookManager) iin);
            }
            return new com.zhaokang.zktestproject.IBookManager.Stub.Proxy(obj);
        }

        @Override
        public android.os.IBinder asBinder() {
            return this;
        }

        @Override
        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException {
            switch (code) {
                case INTERFACE_TRANSACTION: {
                    reply.writeString(DESCRIPTOR);
                    return true;
                }
                case TRANSACTION_getBookList: {
                    data.enforceInterface(DESCRIPTOR);
                    java.util.List&lt;com.zhaokang.zktestproject.Book&gt; _result = this.getBookList();
                    reply.writeNoException();
                    reply.writeTypedList(_result);
                    return true;
                }
                case TRANSACTION_addBook: {
                    data.enforceInterface(DESCRIPTOR);
                    com.zhaokang.zktestproject.Book _arg0;
                    if ((0 != data.readInt())) {
                        _arg0 = com.zhaokang.zktestproject.Book.CREATOR.createFromParcel(data);
                    } else {
                        _arg0 = null;
                    }
                    this.addBook(_arg0);
                    reply.writeNoException();
                    return true;
                }
            }
            return super.onTransact(code, data, reply, flags);
        }

        private static class Proxy implements com.zhaokang.zktestproject.IBookManager {
            private android.os.IBinder mRemote;

            Proxy(android.os.IBinder remote) {
                mRemote = remote;
            }

            @Override
            public android.os.IBinder asBinder() {
                return mRemote;
            }

            public java.lang.String getInterfaceDescriptor() {
                return DESCRIPTOR;
            }

            @Override
            public java.util.List&lt;com.zhaokang.zktestproject.Book&gt; getBookList() throws android.os.RemoteException {
                android.os.Parcel _data = android.os.Parcel.obtain();
                android.os.Parcel _reply = android.os.Parcel.obtain();
                java.util.List&lt;com.zhaokang.zktestproject.Book&gt; _result;
                try {
                    _data.writeInterfaceToken(DESCRIPTOR);
                    mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0);
                    _reply.readException();
                    _result = _reply.createTypedArrayList(com.zhaokang.zktestproject.Book.CREATOR);
                } finally {
                    _reply.recycle();
                    _data.recycle();
                }
                return _result;
            }

            @Override
            public void addBook(com.zhaokang.zktestproject.Book book) throws android.os.RemoteException {
                android.os.Parcel _data = android.os.Parcel.obtain();
                android.os.Parcel _reply = android.os.Parcel.obtain();
                try {
                    _data.writeInterfaceToken(DESCRIPTOR);
                    if ((book != null)) {
                        _data.writeInt(1);
                        book.writeToParcel(_data, 0);
                    } else {
                        _data.writeInt(0);
                    }
                    mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, 0);
                    _reply.readException();
                } finally {
                    _reply.recycle();
                    _data.recycle();
                }
            }
        }

        static final int TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);
        static final int TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1);
    }

    public java.util.List&lt;com.zhaokang.zktestproject.Book&gt; getBookList() throws android.os.RemoteException;

    public void addBook(com.zhaokang.zktestproject.Book book) throws android.os.RemoteException;
}
</code></pre><hr>
<p>再贴下service的代码<br>    package com.zhaokang.zktestproject;</p>
<pre><code>import android.app.Service;
import android.content.Intent;
import android.os.Binder;
import android.os.IBinder;
import android.os.RemoteCallbackList;
import android.os.RemoteException;
import android.os.SystemClock;
import android.util.Log;

import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.atomic.AtomicBoolean;

public class BookManagerService extends Service {

    private static final String TAG = &quot;BMS&quot;;

    private AtomicBoolean mIsServiceDestroyed = new AtomicBoolean(false);

    private CopyOnWriteArrayList&lt;Book&gt; mBookList = new CopyOnWriteArrayList&lt;&gt;();

    private RemoteCallbackList&lt;IOnNewBookArrivedListener&gt; mListenerList = new RemoteCallbackList&lt;&gt;();

    private Binder mBinder = new IBookManager.Stub() {

        @Override
        public List&lt;Book&gt; getBookList() throws RemoteException {
//            SystemClock.sleep(5000);
            return mBookList;
        }

        @Override
        public void addBook(Book book) throws RemoteException {
            mBookList.add(book);
        }

        @Override
        public void registerListener(IOnNewBookArrivedListener listener) throws RemoteException {
//            if (!mListenerList.contains(listener)) {
//                mListenerList.add(listener);
//            } else {
//                Log.i(TAG, &quot;already exist&quot;);
//            }
//            Log.i(TAG, &quot;registerListener, size = &quot; + mListenerList.size());
            mListenerList.register(listener);
        }

        @Override
        public void unRegisterListener(IOnNewBookArrivedListener listener) throws RemoteException {
//            if (mListenerList.contains(listener)) {
//                mListenerList.remove(listener);
//                Log.i(TAG, &quot;unRegisterListener success&quot;);
//            } else {
//                Log.i(TAG, &quot;unRegisterListener fail&quot;);
//            }
//            Log.i(TAG, &quot;unRegisterListener, size = &quot; + mListenerList.size());
            mListenerList.unregister(listener);
        }
    };

    @Override
    public void onCreate() {
        super.onCreate();
        mBookList.add(new Book(1, &quot;android&quot;));
        mBookList.add(new Book(2, &quot;ios&quot;));
        new Thread(new ServiceWorker()).start();
    }

    @Override
    public IBinder onBind(Intent intent) {
        return mBinder;
    }

    private void onNewBookArrived(Book book) throws RemoteException {
        mBookList.add(book);
//        Log.i(TAG, &quot;onNewBookArrived notify listeners&quot; + mListenerList.size());
        final int N = mListenerList.beginBroadcast();
        for (int i = 0; i &lt; N; i++) {
            IOnNewBookArrivedListener listener = mListenerList.getBroadcastItem(i);
            Log.d(TAG, &quot;onNewBookArrived notify listener&quot; + listener);
            listener.onNewBookArrived(book);
        }
    }

    private class ServiceWorker implements Runnable {

        @Override
        public void run() {
            while (!mIsServiceDestroyed.get()) {
                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                int bookId = mBookList.size() + 1;
                Book newBook = new Book(bookId, &quot;new Book#&quot; + bookId);
                try {
                    onNewBookArrived(newBook);
                } catch (RemoteException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
</code></pre><p>stub就是binder类</p>
<pre><code>DESCRIPTOR是binder类名

asInterface(android.os.IBinder obj)将服务端binder转换成客户端需要的接口类型，如果是同进程，返回stub，如果跨进程返回
proxy。

asBinder 返回binder

onTransact  public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) 
该方法运行在服务端的线程池中。
transact翻译来是处理 当客户端发出ipc请求，最终由该方法处理，根据code来判断调用哪个方法，从data中取出数据，用reply返回数据。
如果该方法返回false，客户端的请求会失败。

Proxy#getBookList java.util.List&lt;com.zhaokang.zktestproject.Book&gt; getBookList() 创建data，reply，和最后的返回list

 if ((book != null)) {
    _data.writeInt(1);
     book.writeToParcel(_data, 0);
    } else {
         _data.writeInt(0);
    }
    。。。
 }

如果有参数，就放入data，随后调用服务端的onTransact，同时当前线程挂起，等到onTransact返回reply，随后返回reply的数据

注意点

1. 客户端发起请求后线程会挂起，为了防止影响ui线程，建议在子线程中发起请求。（客户端服务端道理相同）
2. onTransact运行在线程池中，所以必须用同步的方式去执行。
</code></pre><hr>
<pre><code>以上是binder的分析

aidl完全是根据binder的封装的

需要注意的点，两端如果某方法耗时，那么调用方需要在子线程中调用

解绑接口时要使用RemoteCallbckList，由该类来维护所有的进程间接口

服务进程意外断掉的情况，在serviceDisconnected中重连服务，或者给binder设置死亡代理DeathRecipient，重连服务，
我感觉前者比较好用

aidl权限验证：在onBind方法中permission验证，在onTransact方法中permission验证，其余还有包名验证等。
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/02/08/android系统分析/android面试分享/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/08/android系统分析/android面试分享/" itemprop="url">android面试分享</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-08T17:31:32+08:00">2017-02-08</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>首先感谢各个公司给了我面试的机会
</code></pre><p>这段时间在看机会，去了几个面试，把面试到的题目和大家分享一下</p>
<h3 id="某AI公司，面试官非常有耐心，人非常好（好想跟他混。。。）"><a href="#某AI公司，面试官非常有耐心，人非常好（好想跟他混。。。）" class="headerlink" title=" 某AI公司，面试官非常有耐心，人非常好（好想跟他混。。。）"></a><font color="af8888"> 某AI公司，面试官非常有耐心，人非常好（好想跟他混。。。）</font></h3><ol>
<li><p>oauth2.0授权的流程<br> 第三方应用去服务商获取app secret<br> （A）用户打开客户端以后，客户端要求用户给予授权—–跳至服务商页面。</p>
<p> （B）如果用户同意，那么登录，根据用户登录信息和app secret，服务商同意给予客户端授权accessToken。</p>
<p> （C）客户端使用上一步获得的授权accessToken，向资源服务器申请获取资源。</p>
<p> （D）资源服务器确认令牌无误，返回该accessToken的相关数据。</p>
</li>
<li><p><a href="http://clunyes.github.io/2017/03/03/java深入学习/jni浅析/">jni调用</a>.</p>
</li>
<li><p>IPC AIDL的简单实现<br>IPC的各种方式 广播 AIDL Messenger bundle ContentProvider以及socket<br> 要理解aidl要首先理解binder<br> Binder是什么：binder连接前台应用和service的桥梁<br> <a href="http://clunyes.github.io/2017/02/20/android系统分析/AIDL的梳理/">具体aidl怎么实现</a>.</p>
</li>
<li><p>tcp长连接</p>
<p> 采用心跳包来keep-alive<br> keep-alive ：一个连接在２小时内没有任何动作，服务器就向客户机发送一个探测报文，对于客户机：</p>
<pre><code>(1)正常运行，并从服务器可达，TCP响应正常，保活定时器复位(再次获得２小时)
(2)客户机崩溃,关闭或者正在重启，TCP无响应，75秒后超时，服务器稍后发送9个探测报文(共计１０个)，间隔都为75秒。TCP都没有响应，认为客户机已经关闭连接
(3)客户机崩溃并重启完成：服务器将收到一个探测响应，这个响应是一个复位，使得服务器终止这个连接。
(4)客户机正常运行，但是服务器不可达，探测无响应，10次探测后无响应，关闭
</code></pre></li>
<li><p>git命令，git rebase</p>
<p> 因为公司的原因一直在用svn，git都是我个人在玩。所以对于这个问题，还是一脸懵逼，看来还是要多学习。</p>
</li>
<li><p>surfaceView的特性</p>
<p> SurfaceView和View最本质的区别在于，surfaceView是在一个新起的单独线程中，可以重新绘制画面（双缓冲绘制）而View必须在UI的主线程中更新画面。</p>
<p> SurfaceView控件适合内存耗费大、需要频繁刷新的场景，常用于显示游戏、动画、视频等。</p>
<p> 两个重要方法lockCanvas；unlockCanvasAndPost<br> ps什么叫双缓冲：SurfaceView内部会有两块Buffer。调用lockCanvas之后，便可以在bufferA上绘图了。绘完之后，调用unlockCanvasAndPost将bufferA显示再屏幕上，<br> 随后调用lockCanvas，在bufferB上绘图，调用unlockCanvasAndPost将bufferB显示在屏幕上。repeat。</p>
</li>
<li><p>httpdns</p>
<p> httpdns和dns有什么差别<br> httpdns基于http协议<br> httpdns：httpdns使用HTTP协议进行域名解析，代替现有基于udp的dns协议</p>
<p> httpdns优势：防劫持，精准调度，使用场景也是app居多。<br> 下一个问题，怎么用httpdns–阿里云就提供了，但是要按流量收费。</p>
</li>
<li><p>art dalvik的区别</p>
<p> art采用预加载机制，在apk安装时就编译完成，占用空间更多一些。dalvik是动态编译，每次启动都要编译。<br> gc方面，dalvik是同步的，art是部分异步。</p>
</li>
<li><p>事件分发</p>
<p> 三个关键方法：dispatchTouchEvent 是否消耗当前事件<br> onInterceptTouchEvent 是否拦截当前事件<br> onTouchEvent 是否消耗当前事件</p>
<p> 那么这三个方法有啥关系呢</p>
<pre><code>public  boolean dispatchTouchEvent(MotionEvent ev){
    boolean consume = false;
    if(onInterceptTouchEvent(ev)){
        consume = onTouchEvent(ev);
    } else{
        consume = child.dispatchTouchEvent(ev);
    }
    return consume;
}
</code></pre><p> 有些要点需要记住，一个事件序列只能被一个view消耗，</p>
<p> 如果一个事件没有view去处理，那么事件会交给activity处理</p>
<p> ViewGroup的onInterceptTouchEvent默认不调用</p>
<p> view没有onInterceptTouchEvent的方法</p>
<p> 事件传递是由activity–window–view。</p>
</li>
<li><p>layout绘制流程</p>
<p>activity attach方法，创建window建立关联。setContentView</p>
<ol>
<li>如果没有DecorView就创建一个（DecorView包含标题栏和内容栏（经大神验证，标题栏不是状态栏statusBar））</li>
<li>将你的xml，添加到decorView的内容栏contentPatent（R.id.content）</li>
<li>activity回调onContentChanged</li>
<li>最后在onResume中调用makeVisible</li>
</ol>
<p>结构就是DecorView–&gt; ViewGroup（DecorView的内容栏）–&gt; 你的View。</p>
<p>说道这里，必须说一下activity window和view的故事</p>
<pre><code>我们知道view是视图，但是android中view不能单独存在，他必须依附于window之上，window就是负责展示view的。
activity负责控制window的行为，同时window的结果都会回调给activity。
那么view和window是怎么bind起来的呢，通过ViewRootImpl，它就是window和view交互的桥梁。
</code></pre></li>
<li><p>jvm</p>
<p>详见 <a href="http://www.jianshu.com/p/54eb60cfa7bd" target="_blank" rel="noopener">http://www.jianshu.com/p/54eb60cfa7bd</a></p>
</li>
<li><p>内存泄漏</p>
<pre><code>推荐一个很好的文章https://medium.com/freenet-engineering/memory-leaks-in-android-identify-treat-and-avoid-d0b1233acc8#.tny5y511b
说明了几种容易泄漏的点，归总也就是一点activity或者fragment中不要有超过本身生命周期的引用，
否则activity（fragment）无法被回收。

1服务不关，2内部类（网络请求的），3匿名类（也是网络请求） 网络请求，退出务必关闭回收或者取消。
异步线程对控件等用弱引用的方式引用

depth是0的就是泄漏的

文章最后给出了一些建议，关于多线程其实rxjava是非常好的解决方案。
</code></pre></li>
</ol>
<h3 id="某宝公司的电话面试"><a href="#某宝公司的电话面试" class="headerlink" title=" 某宝公司的电话面试"></a><font color="af8888"> 某宝公司的电话面试</font></h3><ol>
<li><p>android生命周期介绍</p>
<p> onCreate<br> onRestart activity从不可见状态切换成可见状态<br> onStart activity已经可见了，但是还在后台<br> onResume activity可见了<br> onPause activity还是可见的，但是不能交互了<br> onStop activity不可见<br> onDestroy</p>
<p> onPause和onStop一般一起触发</p>
</li>
<li><p>activity的四种启动模式</p>
<p> 先介绍两个概念task和taskAffinity，</p>
<pre><code>task：翻译过来就是“任务”，是一组相互有关联的 activity 集合，可以理解为 Activity 是在 task 里面活动的。 
task 存在于一个称为 back stack 的数据结构中，也就是说， task 是以栈的形式去管理 activity 的，
所以也叫可以称为“任务栈”。
taskAffinity：官方文档解释是：&quot;The task that the activity has an affinity for.&quot;，
可以翻译为 activity 相关或者亲和的任务，这个参数标识了一个 Activity 所需要的任务栈的名字。
默认情况下，所有Activity所需的任务栈的名字为应用的包名。 taskAffinity 属性主要和 singleTask 
启动模式或者 allowTaskReparenting 属性配对使用。
</code></pre><p> 正常standard启动模式的activity默认会进入应用报名所属的任务栈中</p>
<p> standard 默认 重新创建</p>
<p> singleTop 栈顶复用，如果栈顶就是这个Activity，那么onNewIntent会被调用</p>
<p> singleTask 栈内复用，在第一次启动这个 Activity 时，系统便会创建一个新的任务，taskAffinity 属性是和 singleTask 模式搭配使用的。<br> 。如果再次调用会弹出目标activity之上的其余activity，回调onNewIntent。还有个特殊参数allowTaskReparenting，如果是true，会转移任务栈。</p>
<p> singleInstance 单独占用一个栈，其余与singleTask一致</p>
</li>
<li><p>远程service的调用<br> localService和remoteService,就是上文的ipc</p>
</li>
<li><p>activity和fragment的区别，fragment的优势<br> fragment对比activity更灵活，fragment轻量级，更加易于管理，易于适配手机和平板。</p>
<p> 生命周期如下图：<br> <img src="/2017/02/08/android系统分析/android面试分享/../../../../images/lifecycle.png" alt=""></p>
</li>
<li><p>最满意的模块和其中使用的设计模式<br> 恩。。</p>
</li>
<li><p>https</p>
<p> http + tls/ssl </p>
</li>
</ol>
<h2 id="单独说一下looper-handler"><a href="#单独说一下looper-handler" class="headerlink" title="单独说一下looper handler"></a>单独说一下looper handler</h2><ul>
<li>每一个线程有一个Looper，looper内部有一个mq</li>
<li>handler有它的特性，handler可以在任意线程发送消息，handler发送的消息都会发送到它关联的looper的mq中<br>（handler的创建会关联一个looper，如果不设置默认是当前线程的looper）</li>
<li>looper会轮询自己的mq来处理消息，交给handler的handleMessage去处理。</li>
</ul>
<p>Looper.loop() looper开始工作</p>
<p><a href="http://clunyes.github.io/2017/02/27/java深入学习/javaThread状态/">深入探讨下线程</a>.</p>
<p><a href="http://clunyes.github.io/2017/02/28/java深入学习/java线程池/">java线程池</a>.</p>
<h3 id="某怡科技面试，android负责人技术还行，感觉是对着android开发艺术探索来面的，不过这本书确实经典"><a href="#某怡科技面试，android负责人技术还行，感觉是对着android开发艺术探索来面的，不过这本书确实经典" class="headerlink" title=" 某怡科技面试，android负责人技术还行，感觉是对着android开发艺术探索来面的，不过这本书确实经典"></a><font color="af8888"> 某怡科技面试，android负责人技术还行，</font>感觉是对着android开发艺术探索来面的，不过这本书确实经典</h3><ol>
<li><p>线程池具体实现有哪几种</p>
<p> FixedThreadPool   线程池固定的线程池<br> CachedThreadPool  线程数上限很大，一有任务就会执行，终止并从缓存中移除那些已有 60 秒钟未被使用的线程。<br> 全部闲置时，线程全部停止，此时线程池不占用内存<br> ScheduledThreadPool  核心线程数固定，非核心线程数目不固定，闲置就会回收。适用于执行定时任务，固定周期的任务。<br> SingleThreadExecutor 单个线程的线程池，是同步的</p>
</li>
<li><p>onMeasure参数意义<br> MeasureSpec 32位的值，高2位是SpecMode，低30位是SpecSize</p>
<p> SpecMode为</p>
<p> UNSPECIFIED 父容器不对view有任何限制</p>
<p> EXACTLY 父容器已经检测出view所需要的具体大小，最终大小就是specSize</p>
<p> AT_MOLT 父容器指定了一个可用的specSize，view的大小不能超过这个specSize</p>
<p> LayoutParam和父容器一起决定MeasureSpec:</p>
<p> layoutParam.match_parent 大小就是窗口大小</p>
<p> layoutParam.wrap_content 大小不定，不能超过窗口大小</p>
<p> 100dp固定大小：为layoutParam指定的大小 </p>
<p> 以上为基础知识</p>
<p> 子元素measureSpec创建和父容器measureSpec和子元素本身的LayoutParam，还有子元素的margin padding有关系</p>
<p> 在写自定义view时，自身大小为具体size,view的specMode都是EXACTLY为childSize，如果是match_content 那么不论是EXACTLY还是AT_MOST都是parentSize，<br> 如果要自身大小为wrap_content，则需要重写onMeasure方法，因为在wrap_content时，view的specMode都是AT_MOST，即会填满父控件，这不是我们想要得效果<br> 如何重写，在onMeasure中判断AT_MOST，将宽高用默认宽高代替。</p>
</li>
<li><p>自定义绘图，旋转</p>
<p> 采用matrix.setRotate的方式，matrix bitmap的关系？</p>
</li>
<li><p>图片3级缓存</p>
<p> 网络缓存, 不优先加载, 速度慢,浪费流量<br> 本地缓存, 次优先加载, 速度快<br> 内存缓存, 优先加载, 速度最快</p>
</li>
<li><p>activity的启动过程</p>
<p> <a href="http://clunyes.github.io/2017/02/24/android系统分析/activity启动和service启动/">详细说明</a></p>
</li>
<li><p>IntentService<br> service是运行在主线程中的，所以service是不能进行耗时操作的<br> 可以执行耗时的任务的service，内部实现是HandlerThread和handler。HandlerThread是一个有Looper的Thread。<br> 正是由于HandlerThread，IntentService可以进行耗时操作，处理完所有逻辑之后，会自动关闭服务！（这么厉害的东西，之前都没用过）</p>
</li>
<li><p>图片缓存回收的算法    </p>
<pre><code>1. 新数据插入到链表头部；

2. 每当缓存命中（即缓存数据被访问），则将数据移到链表头部；

3. 当链表满的时候，将链表尾部的数据丢弃。
</code></pre><p> LRU，最近最少使用算法<br> LruCache是由LinkedHashMap来实现的，同步实现（因为是不同线程调用的）。</p>
<p> 图片缓存的是drawable。</p>
</li>
<li><p>并发场景，争夺资源</p>
<p> <a href="http://clunyes.github.io/2017/03/01/java深入学习/java线程安全/">synchronized</a></p>
</li>
</ol>
<h3 id="扩展问题"><a href="#扩展问题" class="headerlink" title=" 扩展问题"></a><font color="af8888"> 扩展问题</font></h3><ol>
<li><p>数据结构有哪些</p>
<pre><code>1. 逻辑结构分为:集合结构；线性结构；树形结构；图形结构
2. 物理（计算机存储）结构：顺序存储结构，数组；链式存储结构，链表
</code></pre><p>数组 String[] 包括列表</p>
<p>链表 LinkedList</p>
<p>栈 activity task 就是一个栈，先进后出</p>
<p>队列  基本上，一个队列就是一个先入先出（FIFO）的数据结构</p>
<p>树</p>
<p>图</p>
</li>
<li><p>java  copyOnWrite思路，<br> <a href="http://clunyes.github.io/2017/02/28/java深入学习/java集合理解/">各种集合类的实现</a></p>
</li>
<li><p><a href="http://clunyes.github.io/2017/02/22/android热修复原理/">android 热修复原理</a></p>
</li>
<li><p>android保活</p>
<ol>
<li><p>不同app利用广播相互唤醒</p>
</li>
<li><p>开启前台服务，不显示notification–这种方式还是会被杀死的</p>
</li>
<li><p>如果够牛逼，进入系统的白名单</p>
</li>
<li><p>一个像素的activity</p>
</li>
<li><p>JobScheduler（有待验证怎么使用的）</p>
<p>进程回收机制：系统内存不足的情况下android会开始杀进程，所使用的机制就是Low Memory Killer。</p>
<p>oom_adj值越低越不会被杀死</p>
<p>app退到后台时，其所有的进程优先级都会降低。但是UI进程是降低最为明显的，因为它占用的内存资源最多，<br>系统内存不足的时候肯定优先杀这些占用内存高的进程来腾出资源。所以，为了尽量避免后台UI进程被杀，<br>需要尽可能的释放一些不用的资源，尤其是图片、音视频之类的。</p>
<p>目前来讲，app进入到后台后，如果资源紧张肯定会被kill。</p>
</li>
</ol>
</li>
<li><p>生产者消费者模式</p>
</li>
<li><p>android优化</p>
<ol>
<li>内存泄漏方面</li>
<li>ui视图绘制慢导致卡顿</li>
<li>严苛模式</li>
<li>启动优化–不必要在application中初始化的代码，放到ui初始化完成后。</li>
</ol>
</li>
<li><p>socket的基本流程<br> <img src="/2017/02/08/android系统分析/android面试分享/../../../../images/socket主流程.png" alt=""></p>
</li>
</ol>
<h3 id="唯X科技面试，有一句说一句，面试官是架构师技术非常不错，人很谦和，"><a href="#唯X科技面试，有一句说一句，面试官是架构师技术非常不错，人很谦和，" class="headerlink" title=" 唯X科技面试，有一句说一句，面试官是架构师技术非常不错，人很谦和，"></a><font color="af8888"> 唯X科技面试，</font>有一句说一句，面试官是架构师技术非常不错，人很谦和，</h3><p>面试官表示我还是个中级。哎，慢慢面吧。</p>
<ol>
<li><p>android ndk 开发</p>
</li>
<li><p>对于android framework的理解</p>
</li>
<li><p>源码要自己敲一遍，理解更加深刻</p>
</li>
<li><p>app启动时间优化 adb shell am start -W cn.mynewclouedeu/cn.mynewclouedeu.ui.activity.ActivityGuide<br>查出启动时间，application初始化使用线程操作。</p>
</li>
<li><p>java与模式，理解低耦合高内聚</p>
</li>
<li><p>动态注册广播比静态注册广播先收到广播</p>
</li>
<li><p>图片压缩，高清晰度，仿微信</p>
</li>
<li><p>aop 面向切面编程</p>
</li>
<li><p>增量更新</p>
</li>
<li><p>注解的理解</p>
</li>
</ol>
<p>这道问题非常考验功力，慢慢修炼。</p>
<h3 id="X联动力面试，面试流程比较奇葩的，提了个需求问行不行"><a href="#X联动力面试，面试流程比较奇葩的，提了个需求问行不行" class="headerlink" title=" X联动力面试，面试流程比较奇葩的，提了个需求问行不行"></a><font color="af8888"> X联动力面试，</font>面试流程比较奇葩的，提了个需求问行不行</h3><ol>
<li><p>需要要和硬件打交道（jni hal你都得会）</p>
</li>
<li><p>自己公司有自己的视频流协议（视频流的协议，通信协议你得熟悉）</p>
</li>
<li><p>要做android app开发（app相关你也得过关）</p>
</li>
</ol>
<p>要求还是挺高的，如果去做的话对于我这样的工程师估计够呛。</p>
<p>顺利的面试我就不发了，目标还是定在大厂，不是大厂也得是大牛领导，实在是不想再去坑爹公司。   </p>
<p>又发现了一个大牛的面经： <a href="http://www.jianshu.com/p/dea7c3555b3c" target="_blank" rel="noopener">http://www.jianshu.com/p/dea7c3555b3c</a>    ，不得不说基础很重要。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/01/22/rxjava/rxjava转换操作符/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/22/rxjava/rxjava转换操作符/" itemprop="url">rxjava转换操作符</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-22T14:42:24+08:00">2017-01-22</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="转换操作符"><a href="#转换操作符" class="headerlink" title="转换操作符"></a>转换操作符</h2><h3 id="buffer操作符"><a href="#buffer操作符" class="headerlink" title="buffer操作符"></a>buffer操作符</h3><p>buffer操作符周期性地收集源Observable产生的结果到列表中，并把这个列表提交给订阅者，<br>订阅者处理后，清空buffer列表，同时接收下一次收集的结果并提交给订阅者，周而复始。</p>
<h3 id="flatMap操作符"><a href="#flatMap操作符" class="headerlink" title="flatMap操作符"></a>flatMap操作符</h3><p>flatMap操作符是把Observable产生的结果转换成多个Observable，然后把这多个Observable“扁平化”成一个Observable，并依次提交产生的结果给订阅者。</p>
<h3 id="concatMap操作符"><a href="#concatMap操作符" class="headerlink" title="concatMap操作符"></a>concatMap操作符</h3><p>cancatMap操作符与flatMap操作符类似，都是把Observable产生的结果转换成多个Observable，然后把这多个Observable“扁平化”成一个Observable，并依次提交产生的结果给订阅者。<br>cancat是有顺序的。</p>
<p>### </p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/01/21/rxjava/rxjava创建操作符/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/21/rxjava/rxjava创建操作符/" itemprop="url">rxjava操作符</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-21T09:42:17+08:00">2017-01-21</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://blog.csdn.net/job_hesc/article/details/45798307" target="_blank" rel="noopener">操作符这里讲解的很仔细</a></p>
<p>RxJava的强大之处，在于它提供了非常丰富且功能强悍的操作符，通过使用和组合这些操作符，你几乎能完成所有你想要完成的任务</p>
<ul>
<li>(Observable的创建操作符)，比如：Observable.create()、Observable.just()、Observable.from()等等；</li>
<li>(Observable的转换操作符)，比如：observable.map()、observable.flatMap()、observable.buffer()等等；</li>
<li>(Observable的过滤操作符)，比如：observable.filter()、observable.sample()、observable.take()等等；</li>
<li>(Observable的组合操作符)，比如：observable.join()、observable.merge()、observable.combineLatest()等等；</li>
<li>(Observable的错误处理操作符)，比如:observable.onErrorResumeNext()、observable.retry()等等；</li>
<li>(Observable的功能性操作符)，比如：observable.subscribeOn()、observable.observeOn()、observable.delay()等等；</li>
<li>(Observable的条件操作符)，比如：observable.amb()、observable.contains()、observable.skipUntil()等等；</li>
<li>(Observable数学运算及聚合操作符)，比如：observable.count()、observable.reduce()、observable.concat()等等；</li>
<li>其他如observable.toList()、observable.connect()、observable.publish()等等；</li>
</ul>
<h2 id="创建操作符"><a href="#创建操作符" class="headerlink" title="创建操作符"></a>创建操作符</h2><ul>
<li>常用的创建操作符还是： create from timer interval（像range just defer真是没用过）<h3 id="create操作符"><a href="#create操作符" class="headerlink" title="create操作符"></a>create操作符</h3></li>
</ul>
<p>create操作符是所有创建型操作符的“根”，也就是说其他创建型操作符最后都是通过create操作符来创建Observable的</p>
<h3 id="from操作符"><a href="#from操作符" class="headerlink" title="from操作符"></a>from操作符</h3><p>from操作符是把其他类型的对象和数据类型转化成Observable</p>
<h3 id="just操作符"><a href="#just操作符" class="headerlink" title="just操作符"></a>just操作符</h3><p>just操作符也是把其他类型的对象和数据类型转化成Observable，它和from操作符很像，只是方法的参数有所差别</p>
<h3 id="defer操作符"><a href="#defer操作符" class="headerlink" title="defer操作符"></a>defer操作符</h3><p>defer操作符是直到有订阅者订阅时，才通过Observable的工厂方法创建Observable并执行，defer操作符能够保证Observable的状态是最新的</p>
<h3 id="timer操作符"><a href="#timer操作符" class="headerlink" title="timer操作符"></a>timer操作符</h3><p>timer操作符是创建一串连续的数字，产生这些数字的时间间隔是一定的</p>
<h3 id="interval操作符"><a href="#interval操作符" class="headerlink" title="interval操作符"></a>interval操作符</h3><p>interval操作符是每隔一段时间就产生一个数字，这些数字从0开始，一次递增1直至无穷大；interval操作符的实现效果跟上面的timer操作符的第二种情形一样</p>
<h3 id="range操作符"><a href="#range操作符" class="headerlink" title="range操作符"></a>range操作符</h3><p>range操作符是创建一组在从n开始，个数为m的连续数字，比如range(3,10)，就是创建3、4、5…12的一组数字</p>
<h3 id="repeat-repeatWhen操作符"><a href="#repeat-repeatWhen操作符" class="headerlink" title="repeat/repeatWhen操作符"></a>repeat/repeatWhen操作符</h3><p>repeat操作符是对某一个Observable，重复产生多次结果</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/01/09/life/搞笑记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/09/life/搞笑记录/" itemprop="url">搞笑记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-09T19:08:26+08:00">2017-01-09</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li><p>“小姐，请问一下有没有卖半岛铁盒”<br>“有啊，你从前面右转出门沿着马路直走过三个红绿灯往左拐150米左右有一个车站上38路公交车做13个站下车打一个摩<br>的到天伦不孕不育医院南门门口报刊亭斜对面有一个小巷子进去第三家成人用品店对面进去第二排架子上就有了。”<br>“WQNMLGB!”</p>
</li>
<li><p>作者：那棵树生气了<br>链接：<a href="https://www.zhihu.com/question/40019322/answer/87104083" target="_blank" rel="noopener">https://www.zhihu.com/question/40019322/answer/87104083</a><br>来源：知乎<br>著作权归作者所有，转载请联系作者获得授权。</p>
<pre><code>春江潮水连海平，敌法主B运魔瓶

初生牛犊不怕虎，火枪裸鞋一保五

滟滟随波千万里，幻刺草鞋裸虚灵

我自横刀向天笑，给我这波我辉耀

春眠不觉晓，白牛到处跑

醉里挑灯看剑，还是火枪最贱

粉身碎骨浑不怕，补刀大树保敌法

秦时明月汉时关，混沌开大打肉山

白发三千丈，队友都在浪

停车坐爱枫林晚，自己大哥没人管

虎落平阳被犬欺，骷髅倒下没蓝起

少年不识愁滋味，潮汐跳大娜迦睡

天生我才必有用，快快扶我还能送

问君能有几多愁，五只地卜遇老牛

巴山楚水凄凉地，敌法女王都有B

怀旧空吟闻笛赋，B到高台被卡住。

四塞忽闻狼烟起，潮汐跳刀大空气

万水千山总是情，给颗吃树行不行

春色满园关不住，想玩辅助选老鹿

黄沙百战穿金甲，团战领导来电话

我自横刀向天笑，吓得小牛大完跳

别有幽愁暗恨生，三级大招忘了升

冰女不知亡国恨，假腿挑战先锋盾

两岸猿声啼不住，猴子还在憋遗物

昨夜西风凋碧树，一选老鹿当辅助

问君能有几多愁，恰似残血TP不能留

问君欲何志，下马问前程，潮汐猛犸又空大，相知能几人！

忽如一夜春风来，暗牧薄葬一口奶

山重水覆疑无路，转身河道遇极速

捐躯赴国难，舍身踩炸弹

秋水共长天一色，沟壑与刚毛齐飞

醉里挑灯看剑，还是火枪最贱

邻家火女初长成，A帐大你疼不疼？

曾经沧海难为水，买活飞鞋继续怼

天若有情天亦老，养我吃树好不好

锦瑟无端五十弦，刷新A杖二十连

古道西风瘦马，屠夫钩死光法

莫愁前路无知己，白牛全图追着你

路见不平一声吼，一转两转全带走

人生自古谁无死，团战影魔必须死

老夫聊发少年狂，左黑黄，右勋章，冰眼法球，逃跑用微光。

洛阳亲友如相问，别说狼人在偷盾。
</code></pre></li>
<li><p>股灾之前有哪些信号预示股灾的来临？</p>
</li>
</ol>
<pre><code>高考结束学生背着书包拿压岁钱去开户
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2016/12/12/rxjava/rxjava学习-基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/12/rxjava/rxjava学习-基础/" itemprop="url">rxjava学习-基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-12T15:45:40+08:00">2016-12-12</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##Rxjava 使用笔记<br>最近使用新的框架进行开发，其中最为困惑的就是rxjava，确实入门比较难。<br>经过反复的更改，最终改名rxjava学习-基础，确实需要仔细理解。</p>
<p>###1.20<br>今天终于把2.0项目上线了，那么就系统学习下rxjava，<a href="https://github.com/yuxingxin/RxJava-Essentials-CN" target="_blank" rel="noopener">学习资料在这里</a><br>我直接贴过来了，下面的介绍说的很明白</p>
<ul>
<li>响应式编程是一种基于异步数据流概念的编程模式。数据流就像一条河：它可以被观测，被过滤，被操作，或者为新的消费者与另外一条流合并为一条新的流。</li>
<li>响应式编程的一个关键概念是事件。事件可以被等待，可以触发过程，也可以触发其它事件。事件是唯一的以合适的方式将我们的现实世界映射到我们的软件中：<br>如果屋里太热了我们就打开一扇窗户。同样的，当我们更改电子表（变化的传播）中的一些数值时，我们需要更新整个表格或者我们的机器人碰到墙时会转弯（响应事件）。</li>
<li>今天，响应式编程最通用的一个场景是UI：我们的移动App必须做出对网络调用、用户触摸输入和系统弹框的响应。在这个世界上，软件之所以是事件驱动并响应的是因为现实生活也是如此。</li>
</ul>
<p>rx特点</p>
<ol>
<li>一致性</li>
<li>可扩展：这个在编码过程中特别有感觉。只要思路够清晰，一句话就能把业务处理完，不管同步异步都没问题。</li>
<li>陈述式</li>
<li>可组合</li>
<li>可转化</li>
</ol>
<p>rx的两个最核心的接口<br>IObserver 和 IObservable，所有的链式都衍生自这两个接口。代码如下：</p>
<pre><code class="android">//Defines a provider for push-based notification.
public interface IObservable&lt;out T&gt; 
{
//Notifies the provider that an observer is to receive notifications.
IDisposable Subscribe(IObserver&lt;T&gt; observer);   
}
</code></pre>
<pre><code class="android">public interface IObserver&lt;in T&gt;
{
//Provides the observer with new data.
void OnNext(T value);
//Notifies the observer that the provider has experienced an error condition.
void OnError(Exception error);
//Notifies the observer that the provider has finished sending push-based notifications.
void OnCompleted();
}
</code></pre>
<p>四种角色</p>
<ul>
<li>Observable</li>
<li>Observer</li>
<li>Subscriber</li>
<li>Subjects</li>
</ul>
<p>Observables和Subjects是两个compose的实体，Observers和Subscribers是两个consume实体。</p>
<p>subject是一个神奇的对象，它可以是一个Observable同时也可以是一个Observer：它作为连接这两个世界的一座桥梁。一个Subject可以订阅一个Observable，<br>就像一个观察者，并且它可以执行新的数据，或者传递它接受到的数据，就像一个Observable。很明显，作为一个Observable，观察者们或者其它Subject都可以订阅它。<br>一旦Subject订阅了Observable，它将会触发Observable开始执行。如果原始的Observable是“冷”的，这将会对订阅一个“热”的Observable变量产生影响。</p>
<p>RxJava提供四种不同的Subject：</p>
<ul>
<li>PublishSubject</li>
<li>BehaviorSubject</li>
<li>ReplaySubject</li>
<li>AsyncSubject</li>
</ul>
<font color="af8888">说实话subject我在开发中没怎么注意到，需要到实战中再理解</font>

<p>BehaviorSubject:<br>简单的说，BehaviorSubject会首先向他的订阅者发送截至订阅前最新的一个数据对象（或初始值）,然后正常发送订阅后的数据流。</p>
<p>ReplaySubject:<br>ReplaySubject会缓存它所订阅的所有数据,向任意一个订阅它的观察者重发。</p>
<p>AsyncSubject<br>当Observable完成时AsyncSubject只会发布最后一个数据给已经订阅的每一个观察者。</p>
<p>(这些subject都带有比较特殊的能力，在特定的业务场景下会有优势)</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2016/12/09/android tip/android-tips/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/09/android tip/android-tips/" itemprop="url">android tips</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-09T15:55:17+08:00">2016-12-09</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="clunyes" />
            
              <p class="site-author-name" itemprop="name">clunyes</p>
              <p class="site-description motion-element" itemprop="description">好想去看dac</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">54</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">clunyes</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Pisces</a> v6.0.6</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.6"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.6"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.6"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.6"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.6"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
