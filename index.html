<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.6" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png?v=6.0.6">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png?v=6.0.6">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png?v=6.0.6">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.6" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.0.6',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="Hexo, NexT" />


<meta name="description" content="好想去看dac">
<meta property="og:type" content="website">
<meta property="og:title" content="clunyes_blog">
<meta property="og:url" content="http://clunyes.github.io/index.html">
<meta property="og:site_name" content="clunyes_blog">
<meta property="og:description" content="好想去看dac">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="clunyes_blog">
<meta name="twitter:description" content="好想去看dac">






  <link rel="canonical" href="http://clunyes.github.io/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>clunyes_blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> 

<div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">clunyes_blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        
          
  <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
</li>

      
        
        
          
  <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />About</a>
</li>

      
        
        
          
  <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
</li>

      

      
    </ul>
  

  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2018/06/08/源码阅读/glide源码学习记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/08/源码阅读/glide源码学习记录/" itemprop="url">glide源码学习记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-08T09:04:12+08:00">2018-06-08</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>preconditions: 优雅的参数检测，以后项目可以用</li>
<li><p>单例</p>
<pre><code>public static Glide get(@NonNull Context context) {
     if (glide == null) {
       synchronized (Glide.class) {
         if (glide == null) {
           checkAndInitializeGlide(context);
         }
       }
     }
    return glide;
  }
</code></pre></li>
<li><p>泛型使用<br>源码中大量使用了泛型，以及泛型方法，泛型接口，泛型类</p>
<p>  E - Element (在集合中使用，因为集合中存放的是元素)</p>
<p>  T - Type（Java 类）， S、U、V  - 2nd、3rd、4th types</p>
<p>  K - Key（键）</p>
<p>  V - Value（值）</p>
<p>  N - Number（数值类型）</p>
<p> ？ -  通配符</p>
</li>
<li><p>分包</p>
<pre><code>glide的包分为
load：加载和解码
manager：生命周期控制
module
provider
request：加载图片的请求
signature：
util
以及默认包
</code></pre><p>分包比较简练，对外提供简单的接口，比较好懂。内部代码严谨，比较规范。</p>
</li>
<li><p>glide的初始化比较简单：</p>
<pre><code>通过AndroidManifest和@GlideModule注解获取用户自定义配置GlideModule，并调用其对应的方法
通过GlideBuilder构建Glide：
1.新建线程池
2.新建图片缓存池和缓存池
3.新建内存缓存管理器
4.新建默认本地缓存管理器
5.新建请求引擎Engine
6.新建RequestManger检索器
7.新建Glide
Glide构造方法中，新建模型转换器，解码器，转码器，编码器，以及生成Glide上下文GlideContext
通过RequestManager检索器，建立生命周期监听，并建立一个RequestManager
完成！
</code></pre></li>
<li><p>into的逻辑，包含了网络请求，调用比较巧妙，使用了桥接模式</p>
</li>
<li>大量使用了注解，@NonNull，这个就又可以细讲了，大多数编译注解，作为编译期的辅助工具。这些注解自己项目也可以用起来，这样能避免一些空指针。</li>
<li>module的注入</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/05/11/模块化浅析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/11/模块化浅析/" itemprop="url">模块化浅析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-11T17:13:21+08:00">2017-05-11</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>子曰：简单性和模块化是软件工程的基石；分布式和容错性是互联网的生命。
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/03/09/viewStub/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/09/viewStub/" itemprop="url">viewStub</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-09T14:31:59+08:00">2017-03-09</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>动态展示ui的一种方案，节省内存，加快运行速度</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/03/09/android-jni环境搭建/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/09/android-jni环境搭建/" itemprop="url">android-jni环境搭建</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-09T10:20:21+08:00">2017-03-09</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>网上一堆乱七八糟的文章，可以借鉴的并不多。</p>
<p>我来说下我的成功方案吧。</p>
<p>参考 <a href="https://codelabs.developers.google.com/codelabs/android-studio-jni/index.html?index=..%2F..%2Findex#0" target="_blank" rel="noopener">https://codelabs.developers.google.com/codelabs/android-studio-jni/index.html?index=..%2F..%2Findex#0</a></p>
<p>project gradle</p>
<pre><code>// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath &apos;com.android.tools.build:gradle:2.3.0&apos;
        classpath &apos;com.android.tools.build:gradle-experimental:0.9.0&apos;
        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

allprojects {
    repositories {
        jcenter()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}
</code></pre><p>app gradle</p>
<pre><code>apply plugin: &apos;com.android.model.application&apos;
model {
    android {
        compileSdkVersion 25
        buildToolsVersion &quot;25.0.2&quot;
        defaultConfig {
            applicationId &quot;com.zhaokang.ndkapplication&quot;
            minSdkVersion.apiLevel 15
            targetSdkVersion.apiLevel 25
            versionCode 1
            versionName &quot;1.0&quot;
            testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;


        }
        buildTypes {
            release {
                minifyEnabled false
                proguardFiles.add(file(&apos;proguard-android.txt&apos;))
            }
        }
        ndk {
            moduleName &quot;test&quot;
        }
    }
}
dependencies {
    compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])
    androidTestCompile(&apos;com.android.support.test.espresso:espresso-core:2.2.2&apos;, {
        exclude group: &apos;com.android.support&apos;, module: &apos;support-annotations&apos;
    })
    compile &apos;com.android.support:appcompat-v7:25.2.0&apos;
    compile &apos;com.android.support.constraint:constraint-layout:1.0.0-beta4&apos;
    compile &apos;com.android.support:design:25.2.0&apos;
    testCompile &apos;junit:junit:4.12&apos;
}
</code></pre><p>这样下来jni项目就搭建好了。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/03/08/设计模式/系统设计原则/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/08/设计模式/系统设计原则/" itemprop="url">系统设计原则</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-08T16:18:12+08:00">2017-03-08</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这里必须贴一篇文章<a href="http://www.jianshu.com/p/8708f5886ffb" target="_blank" rel="noopener">http://www.jianshu.com/p/8708f5886ffb</a> </p>
<p>讲的非常通俗，或许会解开你的心结。</p>
<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><pre><code>对扩展开放，对修改关闭（低耦合）
</code></pre><h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><pre><code>任何父类能出现的地方，子类也能出现
</code></pre><h2 id="依赖倒置原则-开闭原则是目标，依赖倒置原则是手段"><a href="#依赖倒置原则-开闭原则是目标，依赖倒置原则是手段" class="headerlink" title="依赖倒置原则-开闭原则是目标，依赖倒置原则是手段"></a>依赖倒置原则-开闭原则是目标，依赖倒置原则是手段</h2><pre><code>要依赖抽象，不要依赖实现
</code></pre><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><pre><code>类不应该依赖它不需要的接口
</code></pre><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><pre><code>简单来说，一个类应该是一组相关性非常高的函数、数据的封装。（高内聚）
</code></pre><h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><pre><code>一个对象应该对其他对象有最少的了解
</code></pre><p>MVC MVP或者MVVM是架构模式，比设计模式又高了一层，通常是多个设计模式的组合。 </p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/03/08/android widget/recycleView/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/08/android widget/recycleView/" itemprop="url">recycleView</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-08T09:36:08+08:00">2017-03-08</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>优点：</p>
<pre><code>RecyclerView本身它是不关心视图相关的问题的，由于ListView的紧耦合的问题，
google的改进就是RecyclerView本身不参与任何视图相关的问题。它不关心如何将子View放在合适的位置，
也不关心如何分割这些子View，更不关心每个子View各自的外观。更进一步来说就是RecyclerView它只负责回收和重用的工作，
这也是它名字的由来。

所有关于布局、绘制和其他相关的问题，也就是跟数据展示相关的所有问题，都被委派给了一些”插件化”的类来处理。
这使得RecyclerView的API变得非常灵活。你需要一个新的布局么？接入另一个LayoutManager就可以了！你想要不同的动画么？
接入一个新的ItemAnimator就可以了，诸如此类等等。
</code></pre><p>缺点：</p>
<pre><code>在RecyclerView中，没有一个onItemClickListener方法。所以目前在适配器中处理这样的事件比较好。
如果想要从适配器上添加或移除条目，需要明确通知适配器。这与先前的notifyDataSetChanged()方法稍微有些不同。
具体操作在适配器代码中就可以体现。
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/03/08/设计模式/aop浅谈/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/08/设计模式/aop浅谈/" itemprop="url">aop浅谈</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-08T09:25:43+08:00">2017-03-08</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天比较闲，也没有面试，坐下来看下，昨天面试到的aop。之前是没有接触这个概念，被问到也是一脸懵逼。</p>
<p>顺便说一句，现在工作不好找，去面试必须先过一下面经，先过一下面经，先过一下面经。否则肯定悲剧。</p>
<p>AOP是啥</p>
<pre><code>aop是面向切面的简称（AOP是指在运行时动态地将代码切入到类的指定方法、指定位置上的编程思想），是针对面向对象编程的补充。
</code></pre><hr>
<pre><code>按照OOP的思想, 如果多个类中出现相同的代码, 应该考虑定义一个基类, 将这些相同的代码提取到基类中。
</code></pre><p>AOP的特点</p>
<ol>
<li>不会修改接口</li>
<li>动态添加实现</li>
</ol>
<p>总结来说，AOP是一种设计思想。顺便今天开始看，java与模式吧，几个原则看一下，以后写代码带上脑子写。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/03/03/java深入学习/jni浅析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/03/java深入学习/jni浅析/" itemprop="url">jni浅析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-03T10:51:47+08:00">2017-03-03</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>下面给出一张图，通过此图，我们简要说明一下jni是如何连接Java层和本地层的。</p>
<p><img src="/2017/03/03/java深入学习/jni浅析/../../../../images/jni.jpg" alt="">.</p>
<p>主要注意的有两点：</p>
<ol>
<li>静态代码块：</li>
</ol>
<pre><code>static {  
       System.loadLibrary(&quot;media_jni&quot;);  
       native_init();  
   }  
</code></pre><ol>
<li>native_init的签名：</li>
</ol>
<pre><code>private static native final void native_init();  
</code></pre><p>看到静态代码块后，我们可以知道MediaPlayer对应的jni层代码在Media_jni.so库中</p>
<p>本地层对应的so库是libmedia.so，所以MediaPlayer.java通过Media_jni.so和MediaPlayer.cpp(libmedia.so)进行交互</p>
<pre><code>在Android中，通常java层类和jni层类的名字有如下关系，拿MediaPlayer为例，
java层叫android.media.MediaPlayer.java，那么jni层叫做android_media_MediaPlayer.cpp
</code></pre><p>在java层代用System.loadLibrary成功后，就会调用jni文件中的JNI_onLoad方法，之中涉及到一个gMethods的变量</p>
<pre><code>typedef struct {  
    const char* name;  //java层方法名称
    const char* signature;  //方法在签名
    void* fnPtr;  //在jni层对应的函数名称
} JNINativeMethod; 
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/03/02/android系统分析/app启动优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/02/android系统分析/app启动优化/" itemprop="url">app启动优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-02T17:34:36+08:00">2017-03-02</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>adb shell am start -W cn.mynewclouedeu/cn.mynewclouedeu.ui.activity.ActivityGuide<br>查出启动时间，application初始化使用线程操作。</p>
<p>因为上面这些阶段全部都是在主线程中执行的，任何不经意的操作都可能拖慢应用的启动速度。<br>所以我们不应在Application以及Activity的生命周期回调中做任何费时操作，<br>具体指标大概是你在onCreate，onResume，onStart等回调中所花费的总时间最好不要超过400ms，<br>否则用户在桌面点击你的应用图标后，将感觉到明显的卡顿。但是有些不得以的任务又必须在UI显示之前执行。<br>所以我们要将任务划分优先级。</p>
<pre><code>优先级为1的在应用启动时，就开始加载

优先级为2的在首页渲染完成后，开始加载

优先级为3的在首页渲染完成后，延迟加载 postDelay的方式
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/03/01/java深入学习/HashMap解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/01/java深入学习/HashMap解析/" itemprop="url">HashMap解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-01T16:44:22+08:00">2017-03-01</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>要理解HashMap， 就必须要知道了解其底层的实现， 而底层实现里最重要的就是它的数据结构了，
HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。
</code></pre><h3 id="也就是说HashMap的底层结构是一个数组，而数组的元素是一个单向链表。"><a href="#也就是说HashMap的底层结构是一个数组，而数组的元素是一个单向链表。" class="headerlink" title="也就是说HashMap的底层结构是一个数组，而数组的元素是一个单向链表。"></a>也就是说HashMap的底层结构是一个数组，而数组的元素是一个单向链表。</h3><h3 id="也就是说HashMap的底层结构是一个数组，而数组的元素是一个单向链表。-1"><a href="#也就是说HashMap的底层结构是一个数组，而数组的元素是一个单向链表。-1" class="headerlink" title="也就是说HashMap的底层结构是一个数组，而数组的元素是一个单向链表。"></a>也就是说HashMap的底层结构是一个数组，而数组的元素是一个单向链表。</h3><h3 id="也就是说HashMap的底层结构是一个数组，而数组的元素是一个单向链表。-2"><a href="#也就是说HashMap的底层结构是一个数组，而数组的元素是一个单向链表。-2" class="headerlink" title="也就是说HashMap的底层结构是一个数组，而数组的元素是一个单向链表。"></a>也就是说HashMap的底层结构是一个数组，而数组的元素是一个单向链表。</h3><hr>
<p> 小小的插入，位移方法，&gt;&gt;右移（相当于除以2） &lt;&lt;左移（相当于乘以2）</p>
<pre><code>int number = 10;
System.out.println(Integer.toBinaryString(number));
number = number &gt;&gt; 1;
System.out.println(Integer.toBinaryString(number));
number = number &lt;&lt; 3;
System.out.println(Integer.toBinaryString(number));
</code></pre><hr>
<pre><code>几个关键点：

    hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的；

    如果两个对象相同，就是适用于equals(java.lang.Object) 方法，那么这两个对象的hashCode一定要相同；

    如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，
    一定要和equals方法中使用的一致，否则就会违反上面提到的第2点；

    两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，
    只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里”。
</code></pre><hr>
<p>threshold初始容量  loadFactor加载因子</p>
<pre><code>初始容量，加载因子。这两个参数是影响HashMap性能的重要参数，其中容量表示哈希表中桶的数量，
初始容量是创建哈希表时的容量，加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，
它衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/03/01/java深入学习/volatile关键字/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/01/java深入学习/volatile关键字/" itemprop="url">volatile关键字</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-01T14:54:16+08:00">2017-03-01</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先放一张图，不懂不要紧，说实话看了全篇还是有不懂的</p>
<p><img src="/2017/03/01/java深入学习/volatile关键字/../../../images/volatile.jpg" alt="">.</p>
<p>线程中的三个概念</p>
<p>原子性</p>
<pre><code>对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。

比较难懂。
</code></pre><p>可见性</p>
<pre><code>对于可见性，Java提供了volatile关键字来保证可见性。

当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。
</code></pre><p>有序性</p>
<pre><code>在Java内存模型中，允许编译器和处理器对指令进行重排序，
但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。

相当绕。
</code></pre><p>看个例子：</p>
<pre><code>public class VolatileExample extends Thread{
    //设置类静态变量,各线程访问这同一共享变量
    private  static boolean flag = false;
    //无限循环,等待flag变为true时才跳出循环
   public void run() {
       while (!flag){
       };
       System.out.println(&quot;停止了&quot;);
   }

    public static void main(String[] args) throws Exception {
        new VolatileExample().start();
        //sleep的目的是等待线程启动完毕,也就是说进入run的无限循环体了
        Thread.sleep(100);
        flag = true;
    }
}
</code></pre><p>下面解释一下这段代码为何有可能导致无法中断线程。<br>在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程VolatileExample在运行的时候，<br>会将flag变量的值拷贝一份放在自己的工作内存当中。</p>
<p>那么当线程main更改了flag变量的值之后，但是还没来得及写入主存当中，线程main转去做其他事情了（这个是关键-立马转去做别的事情了），<br>那么线程VolatileExample由于不知道线程main对flag变量的更改，因此还会一直循环下去。</p>
<hr>
<p>使用volatile后<br><img src="/2017/03/01/java深入学习/volatile关键字/../../../images/volatile2.jpg" alt="">.</p>
<p>下面将关键字synchronized和volatile进行一下比较：<br>1）关键字volatile是线程同步的轻量级实现，所以volatile性能肯定比synchronized要好，并且volatile只能修饰于变量，而synchronized可以修饰方法，以及代码块。随着JDK新版本的发布，synchronized关键字在执行效率上得到很大提升，在开发中使用synchronized关键字的比率还是比较大的。</p>
<p>2）多线程访问volatile不会发生阻塞，而synchronized会出现阻塞。</p>
<p>3）volatile能保证数据的可见性，但不能保证原子性；而synchronized可以保证原子性，也可以间接保证可见性，因为它将私有内存和公共内存中的数据做同步。</p>
<p>4）再次重申一下，关键字volatile解决的是变量在多个线程之间的可见性；而synchronized关键字解决的是多个线程之间访问资源的同步性。</p>
<p>除了synchronize还可以用atomic原子，原子数据类型，操作也是原子的。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/03/01/java深入学习/java线程安全/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/01/java深入学习/java线程安全/" itemprop="url">java线程安全</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-01T11:23:00+08:00">2017-03-01</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>如何解决线程安全问题？</p>
<pre><code>基本上所有的并发模式在解决线程安全问题时，都采用“序列化访问临界资源”的方案，即在同一时刻，
只能有一个线程访问临界资源，也称作同步互斥访问。

可以使用synchronized关键字来标记一个方法或者代码块，当某个线程调用该对象的synchronized方法或者访问synchronized代码块时，
这个线程便获得了该对象的锁，其他线程暂时无法访问这个方法，只有等待这个方法执行完毕或者代码块执行完毕，
这个线程才会释放该对象的锁，其他线程才能执行这个方法或者代码块。
</code></pre><hr>
<p>synchronized的使用</p>
<pre><code>synchronized代码块，被修饰的代码成为同步语句块，其作用的范围是调用这个代码块的对象，
我们在用synchronized关键字的时候，能缩小代码段的范围就尽量缩小，能在代码段上加同步就不要再整个方法上加同步。
这叫减小锁的粒度，使代码更大程度的并发。

synchronized方法，被修饰的方法成为同步方法，其作用范围是整个方法，作用对象是调用这个方法的对象。

synchronized静态方法，修饰一个static静态方法，其作用范围是整个静态方法，作用对象是这个类的所有对象。

synchronized类，其作用范围是Synchronized后面括号括起来的部分synchronized(className.class)，作用的对象是这个类的所有对象。

synchronized()，()中是锁住的对象， synchronized(this)锁住的只是对象本身，
同一个类的不同对象调用的synchronized方法并不会被锁住，而synchronized(className.class)实现了全局锁的功能，
所有这个类的对象调用这个方法都受到锁的影响，此外()中还可以添加一个具体的对象，实现给具体对象加锁。
</code></pre><hr>
<pre><code>synchronized (object) {
//在同步代码块中对对象进行操作
}
</code></pre><hr>
<p>synchronized注意事项</p>
<pre><code>当两个并发线程访问同一个对象中的synchronized代码块时，在同一时刻只能有一个线程得到执行，另一个线程受阻塞，必须等待当前线程执行完这个代码块以后才能执行该代码块。两个线程间是互斥的，因为在执行synchronized代码块时会锁定当前的对象，只有执行完该代码块才能释放该对象锁，下一个线程才能执行并锁定该对象。

当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。(两个线程使用的是同一个对象)
当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞(同上，两个线程使用的是同一个对象)。
</code></pre><hr>
<pre><code>当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。
结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。
</code></pre><hr>
<pre><code>每个类也会有一个锁，它可以用来控制对static数据成员的并发访问。
并且如果一个线程执行一个对象的非static synchronized方法，另外一个线程需要执行这个对象所属类的static synchronized方法，
此时不会发生互斥现象，因为访问static synchronized方法占用的是类锁，而访问非static synchronized方法占用的是对象锁，
所以不存在互斥现象。
</code></pre><hr>
<p>   总结：<br>   代码块，方法，静态方法都是方法锁（静态方法比较特殊，和对象锁不共用一个锁）</p>
<p>   object是对象锁</p>
<p>   xx.class 是全局锁</p>
<hr>
<p>面试题</p>
<pre><code>当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？

答：不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。
因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁，如
果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。

synchronized关键字的用法？

答：synchronized关键字可以将对象或者方法标记为同步，以实现对对象和方法的互斥访问，可以用synchronized(对象) 
{ … }定义同步代码块，或者在声明方法时将synchronized作为方法的修饰符。

简述synchronized 和java.util.concurrent.locks.Lock的异同？

答：Lock是Java 5以后引入的新的API，和关键字synchronized相比主要相同点：Lock 能完成synchronized所实现的所有功能；
主要不同点：Lock有比synchronized更精确的线程语义和更好的性能，而且不强制性的要求一定要获得锁。
synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且最好在finally 块中释放（这是释放外部资源的最好的地方）
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/02/28/java深入学习/java线程池/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/28/java深入学习/java线程池/" itemprop="url">java线程池</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-28T17:27:56+08:00">2017-02-28</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先要理清几个类</p>
<pre><code>Executor 接口，只有一个抽象方法，执行runnable任务。

ExecutorService 接口，继承自Executor，添加了一些生命周期管理的方法。
Executor的生命周期有三种状态，运行 ，关闭 ，终止。Executor创建时处于运行状态。
当调用ExecutorService.shutdown()后，处于关闭状态，isShutdown()方法返回true。
这时，不应该再想Executor中添加任务，所有已添加的任务执行完毕后，Executor处于终止状态，isTerminated()返回true。
如果Executor处于关闭状态，往Executor提交任务会抛出unchecked exception RejectedExecutionException。

AbstractExecutorService 抽象类，实现了ExecutorService

ThreadPoolExecutor 实现类，继承自AbstractExecutorService
</code></pre><p>可返回值的任务必须实现Callable接口，类似的，无返回值的任务必须Runnable接口。    </p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/02/28/java深入学习/LinkedList解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/28/java深入学习/LinkedList解析/" itemprop="url">LinkedList解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-28T14:52:48+08:00">2017-02-28</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>LinkedList与ArrayList一样实现List接口，只是ArrayList是List接口的大小可变数组的实现，<br>LinkedList是List接口链表的实现。基于链表实现的方式使得LinkedList在插入和删除时更优于ArrayList，<br>而随机访问则比ArrayList逊色些。</p>
<p><img src="/2017/02/28/java深入学习/LinkedList解析/../../../../images/linkedlist/singleLink.jpg" alt=""></p>
<p><img src="/2017/02/28/java深入学习/LinkedList解析/../../../../images/linkedlist/singleLoopLink.jpg" alt=""></p>
<p><img src="/2017/02/28/java深入学习/LinkedList解析/../../../../images/linkedlist/doubleLink.jpg" alt=""></p>
<p><img src="/2017/02/28/java深入学习/LinkedList解析/../../../../images/linkedlist/doubleLoopLink.jpg" alt=""></p>
<p>LinkedList 是一个双向循环链表</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/02/28/java深入学习/ArrayList解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/28/java深入学习/ArrayList解析/" itemprop="url">ArrayList解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-28T14:13:40+08:00">2017-02-28</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ArrayList 是一个数组队列，相当于动态数组。</p>
<p>难点</p>
<p><img src="/2017/02/28/java深入学习/ArrayList解析/../../../../images/listadd.jpg" alt=""></p>
<p><img src="/2017/02/28/java深入学习/ArrayList解析/../../../../images/listinsert.jpg" alt=""></p>
<p>总结<br>ArrayList和LinkedList的区别</p>
<pre><code>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。
对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。
对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。
</code></pre><p>ArrayList和Vector的区别</p>
<pre><code>Vector和ArrayList几乎是完全相同的,唯一的区别在于Vector是同步类(synchronized)，属于强同步类。因此开销就比ArrayList要大，访问要慢。正常情况下,大多数的Java程序员使用ArrayList而不是Vector,因为同步完全可以由程序员自己来控制。
Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。
Vector还有一个子类Stack.
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/02/28/java深入学习/java集合理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/28/java深入学习/java集合理解/" itemprop="url">java集合理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-28T11:13:26+08:00">2017-02-28</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>近来面试，屡屡被数据结构算法所虐。</p>
<p>所以最近在恶补这方面的知识，想想以前在学校还是too young too simple，要是有老师傅带带我该多好。<br>老师我错了，我真的好想再打Dota，哦不，再学数据结构算法。</p>
<p>Java集合是java提供的工具包，包含了常用的数据结构：集合、链表、队列、栈、数组、映射等。</p>
<p>接下来梳理一下</p>
<pre><code>最主要的接口Collection接口，map接口

Collection接口

    是List、Set和Queue接口的父接口
    定义了可用于操作List、Set和Queue的方法-增删改查

List接口

    List是元素有序并且可以重复的集合，被称为序列
    List可以精确的控制每个元素的插入位置，或删除某个位置元素
    List接口的常用子类：
    ArrayList 
    LinkedList 
    Vector
    Stack

Set接口

    Set接口中不能加入重复元素，无序
    Set接口常用子类：
    散列存放：HashSet
    有序存放：TreeSet

Map和HashMap

Map接口

    Map提供了一种映射关系，其中的元素是以键值对（key-value）的形式存储的，能够实现根据key快速查找value
    Map中的键值对以Entry类型的对象实例形式存在
    键（key值）不可重复，value值可以
    每个建最多只能映射到一个值
    Map接口提供了分别返回key值集合、value值集合以及Entry（键值对）集合的方法
    Map支持泛型，形式如：Map&lt;K,V&gt;

HashMap类

    HashMap是Map的一个重要实现类，也是最常用，基于哈希表实现
    HashMap中的Entry对象是无序排列的
    Key值和Value值都可以为null,但是一个HashMap只能有一个key值为null的映射（key值不可重复）

Comparable和Comparator

Comparable接口——可比较的

    实现该接口表示：这个类的实例可以比较大小，可以进行自然排序
    定义了默认的比较规则
    其实现类需要实现compareTo()方法
    compareTo()方法返回正数表示大，负数表示小0表示相等

Comparator接口——比较工具接口

    用于定义临时比较规则，而不是默认比较规则
    其实现类需要实现compare()方法
    Comparable和Comparator都是Java集合框架的成员

Iterator接口

    集合输出的标准操作
    标准做法，使用Iterator接口
    操作原理：
    Iterator是专门的迭代输出接口，迭代输出就是将元素一个个进行判断，判断其是否有内容，如果有内容则把内容取出。
</code></pre><p><img src="/2017/02/28/java深入学习/java集合理解/../../../../../images/collections.png" alt="">.</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/02/28/android中的各种位置/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/28/android中的各种位置/" itemprop="url">android中的各种位置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-28T10:57:42+08:00">2017-02-28</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2017/02/28/android中的各种位置/../../../images/androidPosition.png" alt="">.</p>
<pre><code>View提供的获取坐标方法
　　getTop()：获取到的是View自身的顶边到其父布局顶边的距离。
　　getLeft()：获取到的是View自身的左边到其父布局左边的距离。
　　getRight()：获取到的是View自身的右边到其父布局左边的距离。
　　getBottom()：获取到的是View自身的底边到其父布局顶边的距离。
</code></pre><hr>
<pre><code>MotionEvent提供的方法
　　getX()：获取点击事件距离控件左边的距离，即视图坐标。
　　getY()：获取点击事件距离控件顶边的距离，即视图坐标。
　　getRawX()：获取点击事件距离整个屏幕左边的距离，即绝对坐标。
　　getRawY()：获取点击事件距离整个屏幕顶边的距离，即绝对坐标。
　　相信通过上图，读者们应该对MotionEvent和Android坐标系有了一个比较清楚的认识。 
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/02/27/java深入学习/javaThread状态/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/27/java深入学习/javaThread状态/" itemprop="url">javaThread状态</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-27T10:51:02+08:00">2017-02-27</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先一个小问题：线程实现可以是thread和runnable，本身两者并没有优劣，但是一个是继承一个是接口，如果你要继承其他类，还是用runnable。</p>
<p>run和start的区别，start方法开启了新线程，run方法没有，start方法不阻塞主线程。</p>
<p>以下是thread的两张状态图，有助于理解线程的生命周期（哪个顺眼你看哪个）。</p>
<p><img src="/2017/02/27/java深入学习/javaThread状态/../../../../images/threadStatus.jpg" alt=""></p>
<p><img src="/2017/02/27/java深入学习/javaThread状态/../../../../images/threadProcess.jpg" alt=""></p>
<p>两个图有个冲突，即join方法，待验证。</p>
<ol>
<li><p>程序通过Thread t = new Thread()，调用t.start()启动一个线程，使该线程进入可运行(Runnable)的状态。</p>
</li>
<li><p>由JVM的决定去调度(Scheduler) 在可运行状态（Runnable）下的线程,使该线程处于运行 (Running) 状态,<br>由于JVM的调度会出现不可控性，即不是优先级高的先被调用，可能先调用，也可能后调用的的情况。运行状态(Running)下，<br>调用礼让yield()方法，可以使线程回到可运行状态(Runnable)下，再次JVM的调度（并不依赖优先级）。</p>
</li>
<li><p>线程在Running的过程中可能会遇到阻塞(Blocked)情况</p>
</li>
</ol>
<p>①．调用join()和sleep()方法，sleep()时间结束或被打断，join()中断,IO完成都会回到Runnable状态，等待JVM的调度。</p>
<p>②．调用wait()，使该线程处于等待池(wait blocked pool),直到notify()/notifyAll()，线程被唤醒被放到锁池(lock blocked pool )<br>，释放同步锁使线程回到可运行状态（Runnable）</p>
<p>③．对Running状态的线程加同步锁(Synchronized)使其进入(lock blocked pool ),同步锁被释放进入可运行状态(Runnable)。</p>
<ol>
<li>线程run()运行结束或异常退出，线程到达死亡状态(Dead)</li>
</ol>
<p>sleep和wait的区别有：</p>
<pre><code>sleep是Thread类的方法,wait是Object类中定义的方法.

Thread.sleep不会导致锁行为的改变, 如果当前线程是拥有锁的, 那么Thread.sleep不会让线程释放锁.

Thread.sleep和Object.wait都会暂停当前的线程. OS会将执行时间分配给其它线程. 区别是, 调用wait后, 
需要别的线程执行notify/notifyAll才能够重新获得CPU执行时间.
</code></pre><p>sleep不会释放锁，yield同样不会释放锁。</p>
<pre><code>join()方法

在很多情况下，主线程创建并启动了线程，如果子线程中进行大量耗时运算，主线程往往将早于子线程结束之前结束。
这时，如果主线程想等待子线程执行完成之后再结束，比如子线程处理一个数据，主线程要取得这个数据中的值，就要用到join()方法了。
方法join()的作用是等待线程对象销毁。
</code></pre><p>线程的上下文切换：</p>
<pre><code>对于单核CPU来说（对于多核CPU，此处就理解为一个核），CPU在一个时刻只能运行一个线程，
当在运行一个线程的过程中转去运行另外一个线程，这个叫做线程上下文切换（对于进程也是类似）。
实际上就是 存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行。
</code></pre><p>停止线程</p>
<p>停止线程是在多线程开发时很重要的技术点，掌握此技术可以对线程的停止进行有效的处理。<br>停止一个线程可以使用Thread.stop()方法，但最好不用它。该方法是不安全的，已被弃用。<br>在Java中有以下3种方法可以终止正在运行的线程：</p>
<pre><code>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止

使用stop方法强行终止线程，但是不推荐使用这个方法，因为stop和suspend及resume一样，都是作废过期的方法，使用他们可能产生不可预料的结果。

使用interrupt方法中断线程，但这个不会终止一个正在运行的线程，还需要加入一个判断才可以完成线程的停止。
</code></pre><p>暂停线程</p>
<pre><code>interrupt()方法
</code></pre><p>线程的优先级</p>
<pre><code>public final static int MIN_PRIORITY = 1;
public final static int NORM_PRIORITY = 5;
public final static int MAX_PRIORITY = 10;
</code></pre><p>守护线程</p>
<pre><code>在Java线程中有两种线程，一种是User Thread（用户线程），另一种是Daemon Thread(守护线程)。

Daemon的作用是为其他线程的运行提供服务，比如说GC线程。
其实User Thread线程和Daemon Thread守护线程本质上来说去没啥区别的，唯一的区别之处就在虚拟机的离开：
如果User Thread全部撤离，那么Daemon Thread也就没啥线程好服务的了，所以虚拟机也就退出了。
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/02/24/android系统分析/activity启动和service启动/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/24/android系统分析/activity启动和service启动/" itemprop="url">activity启动和service启动</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-24T13:49:03+08:00">2017-02-24</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对于android最重要的两个核心组件activity service研究也是比较多的</p>
<p>浅显的问题1： startService和bindService有什么区别：</p>
<pre><code>startService()方式启动，Service是通过接受Intent并且会经历onCreate()和onStartCommand()。当用户在发出意图使之销毁时会经历onDestroy()。
而bindService()方式启动，与Activity绑定的时候，会经历onCreate()和onBind()，而当Activity被销毁的时候，Service会先调用onUnbind()然后是onDestroy()。

使用startService()方法启用服务，调用者与服务之间没有关连，即使调用者退出了，服务仍然运行。
使用bindService()方法启用服务，调用者与服务绑定在了一起，调用者一旦退出，服务也就终止。
</code></pre><p>深入的问题1:<br>Binder优势：<br>Android需要建立一套新的IPC机制来满足系统对通信方式，传输性能和安全性的要求，这就是Binder。<br><a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="noopener">http://blog.csdn.net/universus/article/details/6211589</a> 这篇文章可以反复阅读。</p>
<pre><code>Binder通信的四个角色：

    Client进程：使用服务的进程。
    Server进程：提供服务的进程。
    ServiceManager进程：ServiceManager的作用是将字符形式的Binder名字转化成Client中对该Binder的引用，使得Client能够通过Binder名字获得对Server中Binder实体的引用。
    Binder驱动：驱动负责进程之间Binder通信的建立，Binder在进程之间的传递，Binder引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。
</code></pre><p>那么他们的启动流程到底是怎么样的？</p>
<p>看到一篇非常好的文章<br>activity启动流程文章： <a href="http://www.jianshu.com/p/e0a6717bc75e" target="_blank" rel="noopener">http://www.jianshu.com/p/e0a6717bc75e</a><br>，我就不献丑了</p>
<p>基本流程-两个ipc，应用进程和system server进程，应用进程里涉及到的线程包括ui线程和ApplicationThread</p>
<pre><code>Activty---ActivityManagerProxy : ActvitiyManagerNative--ActivityManagerService

ActivityManagerService--ApplicationThreadProxy : ApplicationThreadNative--ApplicationThread-(H handler)-ActivityThread
</code></pre><p>service和activity流程基本差不多</p>
<p>我这里介绍下一些关键的类</p>
<pre><code>ActivityManagerService （很多都是简称ams，类似的重要服务还有很多PackageManagerService，WindowManagerService）
相当于BookManagerService，是服务端。

服务端提供哪些接口？IBookManager中说明提供了哪些接口。

ActivityManagerNative
怎么和服务端通信呢，要一个AIDL的接口，这个相当于IBookManager.Stub。

ActivityManagerProxy
具体方法的实现在呢，Proxy就是具体实现了

Instrumentation
工具类
</code></pre><p><a href="http://clunyes.github.io/2017/2/20/android系统分析/AIDL的梳理.md/">具体aidl怎么实现</a>请看这里.    </p>
<p>关于AMS，AMS并不是字面意思Activity管理服务，而是service也在其中管理。</p>
<p>启动Activity至少需要两个前提，第一是，应用进程存在，第二AMS已经初始化完毕。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/02/23/android tip/gradle参数说明/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/23/android tip/gradle参数说明/" itemprop="url">gradle参数说明</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-23T18:08:49+08:00">2017-02-23</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>jumboMode 不知道什么意思，和multiDex有类似的功能</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="clunyes" />
            
              <p class="site-author-name" itemprop="name">clunyes</p>
              <p class="site-description motion-element" itemprop="description">好想去看dac</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">39</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">clunyes</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Pisces</a> v6.0.6</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.6"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.6"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.6"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.6"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.6"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
