<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.6" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png?v=6.0.6">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png?v=6.0.6">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png?v=6.0.6">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.6" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.0.6',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="Hexo, NexT" />


<meta name="description" content="好想去看dac">
<meta property="og:type" content="website">
<meta property="og:title" content="clunyes_blog">
<meta property="og:url" content="http://clunyes.github.io/index.html">
<meta property="og:site_name" content="clunyes_blog">
<meta property="og:description" content="好想去看dac">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="clunyes_blog">
<meta name="twitter:description" content="好想去看dac">






  <link rel="canonical" href="http://clunyes.github.io/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>clunyes_blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> 

<div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">clunyes_blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        
          
  <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
</li>

      
        
        
          
  <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />About</a>
</li>

      
        
        
          
  <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
</li>

      

      
    </ul>
  

  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2018/06/08/源码阅读/glide源码学习记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/08/源码阅读/glide源码学习记录/" itemprop="url">glide源码学习记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-08T09:04:12+08:00">2018-06-08</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>preconditions: 优雅的参数检测，以后项目可以用</li>
<li><p>单例</p>
<pre><code>public static Glide get(@NonNull Context context) {
     if (glide == null) {
       synchronized (Glide.class) {
         if (glide == null) {
           checkAndInitializeGlide(context);
         }
       }
     }
    return glide;
  }
</code></pre></li>
<li><p>泛型使用<br>源码中大量使用了泛型，以及泛型方法，泛型接口，泛型类</p>
<p>  E - Element (在集合中使用，因为集合中存放的是元素)</p>
<p>  T - Type（Java 类）， S、U、V  - 2nd、3rd、4th types</p>
<p>  K - Key（键）</p>
<p>  V - Value（值）</p>
<p>  N - Number（数值类型）</p>
<p> ？ -  通配符</p>
</li>
<li><p>分包</p>
<pre><code>glide的包分为
load：加载和解码
manager：生命周期控制
module
provider
request：加载图片的请求
signature：
util
以及默认包
</code></pre><p>分包比较简练，对外提供简单的接口，比较好懂。内部代码严谨，比较规范。</p>
</li>
<li><p>glide的初始化比较简单：</p>
<pre><code>通过AndroidManifest和@GlideModule注解获取用户自定义配置GlideModule，并调用其对应的方法
通过GlideBuilder构建Glide：
1.新建线程池
2.新建图片缓存池和缓存池
3.新建内存缓存管理器
4.新建默认本地缓存管理器
5.新建请求引擎Engine
6.新建RequestManger检索器
7.新建Glide
Glide构造方法中，新建模型转换器，解码器，转码器，编码器，以及生成Glide上下文GlideContext
通过RequestManager检索器，建立生命周期监听，并建立一个RequestManager
完成！
</code></pre></li>
<li><p>into的逻辑，包含了网络请求，调用比较巧妙，使用了桥接模式</p>
</li>
<li>大量使用了注解，@NonNull，这个就又可以细讲了，大多数编译注解，作为编译期的辅助工具。这些注解自己项目也可以用起来，这样能避免一些空指针。</li>
<li>module的注入</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/05/11/模块化浅析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/11/模块化浅析/" itemprop="url">模块化浅析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-11T17:13:21+08:00">2017-05-11</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>子曰：简单性和模块化是软件工程的基石；分布式和容错性是互联网的生命。
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/03/09/viewStub/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/09/viewStub/" itemprop="url">viewStub</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-09T14:31:59+08:00">2017-03-09</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>动态展示ui的一种方案，节省内存，加快运行速度</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/03/09/android-jni环境搭建/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/09/android-jni环境搭建/" itemprop="url">android-jni环境搭建</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-09T10:20:21+08:00">2017-03-09</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>网上一堆乱七八糟的文章，可以借鉴的并不多。</p>
<p>我来说下我的成功方案吧。</p>
<p>参考 <a href="https://codelabs.developers.google.com/codelabs/android-studio-jni/index.html?index=..%2F..%2Findex#0" target="_blank" rel="noopener">https://codelabs.developers.google.com/codelabs/android-studio-jni/index.html?index=..%2F..%2Findex#0</a></p>
<p>project gradle</p>
<pre><code>// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath &apos;com.android.tools.build:gradle:2.3.0&apos;
        classpath &apos;com.android.tools.build:gradle-experimental:0.9.0&apos;
        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

allprojects {
    repositories {
        jcenter()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}
</code></pre><p>app gradle</p>
<pre><code>apply plugin: &apos;com.android.model.application&apos;
model {
    android {
        compileSdkVersion 25
        buildToolsVersion &quot;25.0.2&quot;
        defaultConfig {
            applicationId &quot;com.zhaokang.ndkapplication&quot;
            minSdkVersion.apiLevel 15
            targetSdkVersion.apiLevel 25
            versionCode 1
            versionName &quot;1.0&quot;
            testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;


        }
        buildTypes {
            release {
                minifyEnabled false
                proguardFiles.add(file(&apos;proguard-android.txt&apos;))
            }
        }
        ndk {
            moduleName &quot;test&quot;
        }
    }
}
dependencies {
    compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])
    androidTestCompile(&apos;com.android.support.test.espresso:espresso-core:2.2.2&apos;, {
        exclude group: &apos;com.android.support&apos;, module: &apos;support-annotations&apos;
    })
    compile &apos;com.android.support:appcompat-v7:25.2.0&apos;
    compile &apos;com.android.support.constraint:constraint-layout:1.0.0-beta4&apos;
    compile &apos;com.android.support:design:25.2.0&apos;
    testCompile &apos;junit:junit:4.12&apos;
}
</code></pre><p>这样下来jni项目就搭建好了。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/03/08/android widget/recycleView/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/08/android widget/recycleView/" itemprop="url">recycleView</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-08T09:36:08+08:00">2017-03-08</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>优点：</p>
<pre><code>RecyclerView本身它是不关心视图相关的问题的，由于ListView的紧耦合的问题，
google的改进就是RecyclerView本身不参与任何视图相关的问题。它不关心如何将子View放在合适的位置，
也不关心如何分割这些子View，更不关心每个子View各自的外观。更进一步来说就是RecyclerView它只负责回收和重用的工作，
这也是它名字的由来。

所有关于布局、绘制和其他相关的问题，也就是跟数据展示相关的所有问题，都被委派给了一些”插件化”的类来处理。
这使得RecyclerView的API变得非常灵活。你需要一个新的布局么？接入另一个LayoutManager就可以了！你想要不同的动画么？
接入一个新的ItemAnimator就可以了，诸如此类等等。
</code></pre><p>缺点：</p>
<pre><code>在RecyclerView中，没有一个onItemClickListener方法。所以目前在适配器中处理这样的事件比较好。
如果想要从适配器上添加或移除条目，需要明确通知适配器。这与先前的notifyDataSetChanged()方法稍微有些不同。
具体操作在适配器代码中就可以体现。
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/03/02/android系统分析/app启动优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/02/android系统分析/app启动优化/" itemprop="url">app启动优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-02T17:34:36+08:00">2017-03-02</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>adb shell am start -W cn.mynewclouedeu/cn.mynewclouedeu.ui.activity.ActivityGuide<br>查出启动时间，application初始化使用线程操作。</p>
<p>因为上面这些阶段全部都是在主线程中执行的，任何不经意的操作都可能拖慢应用的启动速度。<br>所以我们不应在Application以及Activity的生命周期回调中做任何费时操作，<br>具体指标大概是你在onCreate，onResume，onStart等回调中所花费的总时间最好不要超过400ms，<br>否则用户在桌面点击你的应用图标后，将感觉到明显的卡顿。但是有些不得以的任务又必须在UI显示之前执行。<br>所以我们要将任务划分优先级。</p>
<pre><code>优先级为1的在应用启动时，就开始加载

优先级为2的在首页渲染完成后，开始加载

优先级为3的在首页渲染完成后，延迟加载 postDelay的方式
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/02/28/android中的各种位置/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/28/android中的各种位置/" itemprop="url">android中的各种位置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-28T10:57:42+08:00">2017-02-28</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2017/02/28/android中的各种位置/../../../images/androidPosition.png" alt="">.</p>
<pre><code>View提供的获取坐标方法
　　getTop()：获取到的是View自身的顶边到其父布局顶边的距离。
　　getLeft()：获取到的是View自身的左边到其父布局左边的距离。
　　getRight()：获取到的是View自身的右边到其父布局左边的距离。
　　getBottom()：获取到的是View自身的底边到其父布局顶边的距离。
</code></pre><hr>
<pre><code>MotionEvent提供的方法
　　getX()：获取点击事件距离控件左边的距离，即视图坐标。
　　getY()：获取点击事件距离控件顶边的距离，即视图坐标。
　　getRawX()：获取点击事件距离整个屏幕左边的距离，即绝对坐标。
　　getRawY()：获取点击事件距离整个屏幕顶边的距离，即绝对坐标。
　　相信通过上图，读者们应该对MotionEvent和Android坐标系有了一个比较清楚的认识。 
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/02/24/android系统分析/activity启动和service启动/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/24/android系统分析/activity启动和service启动/" itemprop="url">activity启动和service启动</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-24T13:49:03+08:00">2017-02-24</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对于android最重要的两个核心组件activity service研究也是比较多的</p>
<p>浅显的问题1： startService和bindService有什么区别：</p>
<pre><code>startService()方式启动，Service是通过接受Intent并且会经历onCreate()和onStartCommand()。当用户在发出意图使之销毁时会经历onDestroy()。
而bindService()方式启动，与Activity绑定的时候，会经历onCreate()和onBind()，而当Activity被销毁的时候，Service会先调用onUnbind()然后是onDestroy()。

使用startService()方法启用服务，调用者与服务之间没有关连，即使调用者退出了，服务仍然运行。
使用bindService()方法启用服务，调用者与服务绑定在了一起，调用者一旦退出，服务也就终止。
</code></pre><p>深入的问题1:<br>Binder优势：<br>Android需要建立一套新的IPC机制来满足系统对通信方式，传输性能和安全性的要求，这就是Binder。<br><a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="noopener">http://blog.csdn.net/universus/article/details/6211589</a> 这篇文章可以反复阅读。</p>
<pre><code>Binder通信的四个角色：

    Client进程：使用服务的进程。
    Server进程：提供服务的进程。
    ServiceManager进程：ServiceManager的作用是将字符形式的Binder名字转化成Client中对该Binder的引用，使得Client能够通过Binder名字获得对Server中Binder实体的引用。
    Binder驱动：驱动负责进程之间Binder通信的建立，Binder在进程之间的传递，Binder引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。
</code></pre><p>那么他们的启动流程到底是怎么样的？</p>
<p>看到一篇非常好的文章<br>activity启动流程文章： <a href="http://www.jianshu.com/p/e0a6717bc75e" target="_blank" rel="noopener">http://www.jianshu.com/p/e0a6717bc75e</a><br>，我就不献丑了</p>
<p>基本流程-两个ipc，应用进程和system server进程，应用进程里涉及到的线程包括ui线程和ApplicationThread</p>
<pre><code>Activty---ActivityManagerProxy : ActvitiyManagerNative--ActivityManagerService

ActivityManagerService--ApplicationThreadProxy : ApplicationThreadNative--ApplicationThread-(H handler)-ActivityThread
</code></pre><p>service和activity流程基本差不多</p>
<p>我这里介绍下一些关键的类</p>
<pre><code>ActivityManagerService （很多都是简称ams，类似的重要服务还有很多PackageManagerService，WindowManagerService）
相当于BookManagerService，是服务端。

服务端提供哪些接口？IBookManager中说明提供了哪些接口。

ActivityManagerNative
怎么和服务端通信呢，要一个AIDL的接口，这个相当于IBookManager.Stub。

ActivityManagerProxy
具体方法的实现在呢，Proxy就是具体实现了

Instrumentation
工具类
</code></pre><p><a href="http://clunyes.github.io/2017/2/20/android系统分析/AIDL的梳理.md/">具体aidl怎么实现</a>请看这里.    </p>
<p>关于AMS，AMS并不是字面意思Activity管理服务，而是service也在其中管理。</p>
<p>启动Activity至少需要两个前提，第一是，应用进程存在，第二AMS已经初始化完毕。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/02/23/android tip/gradle参数说明/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/23/android tip/gradle参数说明/" itemprop="url">gradle参数说明</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-23T18:08:49+08:00">2017-02-23</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>jumboMode 不知道什么意思，和multiDex有类似的功能</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/02/22/android热修复原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/22/android热修复原理/" itemprop="url">android热修复原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-22T17:42:36+08:00">2017-02-22</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>目前常用的热修复技术</p>
<pre><code>AndFix   采用的是Native hook方案

Nuwa, HotFix, RocooFix  采用的是QQ空间提出的Classloader替换类的方案

Tinker  采用的是Instant Run的冷插拔原理的Dex替换
</code></pre><p>以下一一分析</p>
<pre><code>native hook：  在native层进行指针替换，AndFix基于修复包和原生包的区别，加入注解，
通过这份注解来找到要替换的方法，如果可以就会hook该方法并进行替换。
</code></pre><hr>
<pre><code>Nuwa Hotfix RocooFix这些方案是基于dex分包方案
</code></pre><hr>
<pre><code>什么是dex分包：

当 Android 系统安装一个应用的时候，有一步是对 Dex 进行优化，这个过程有一个专门的工具来处理，叫 DexOpt。DexOpt 
是在第一次加载 Dex 文件的时候执行的。这个过程会生成一个 ODEX 文件，即 Optimised Dex。
执行 ODEX 的效率会比直接执行 Dex 文件的效率要高很多。

但是在早期的 Android 系统中，DexOpt 有两个问题。
（一）：DexOpt 会把每一个类的方法 id 检索起来，存在一个链表结构里面，但是这个链表的长度是用一个 short 类型来保存的，
导致了方法 id 的数目不能够超过65536个。一个dex文件最多只支持65536个方法。
（官方提出了multidex的解决方案）

（二）：Dexopt 使用 LinearAlloc 来存储应用的方法信息。Dalvik LinearAlloc 是一个固定大小的缓冲区。
在Android 版本的历史上，LinearAlloc 分别经历了4M/5M/8M/16M限制。Android 2.2和2.3的缓冲区只有5MB，
Android 4.x提高到了8MB 或16MB。当方法数量过多导致超出缓冲区大小时，也会造成dexopt崩溃。
</code></pre><hr>
<pre><code>由于上述问题的存在，通过不断研究，便有了dex分包的解决方案。
</code></pre><hr>
<pre><code>简单来说，其原理是将编译好的class文件拆分打包成两个dex，绕过dex方法数量的限制以及安装时的检查，在运行时再动态加载第二个dex文件中。
原则上两个dex的类是没有重复的 ，如果classes.dex和classes1.dex中有重复的类，当用到这个重复的类的时候，系统会选择哪个类进行加载呢？
</code></pre><p>理论知识来了：<br>    一个ClassLoader可以包含多个dex文件，每个dex文件是一个Element，多个dex文件排列成一个有序的数组dexElements，<br>当找类的时候，会按顺序遍历dex文件，然后从当前遍历的dex文件中找类，如果找类则返回，如果找不到从下一个dex文件继续查找。</p>
<p>那么，如果有重复的类，以前面的dex为准。把有问题的类打包到一个dex（patch.dex）中去，然后把这个dex插入到Elements的最前面，就能实现热修复了。</p>
<p>理论到此为止。</p>
<hr>
<pre><code>Tinker的原理：Instant Run的冷插拔，完全使用了新的Dex，但是又不能直接替换dex，那么怎么做呢。

在编译时通过新旧两个Dex生成差异patch.dex。在运行时，将差异patch.dex重新跟原始安装包的旧Dex还原为新的Dex。
这里就涉及到怎么最优算patch包的问题。

这套方案有两个缺点：占用更多空间。

一个额外的合成过程；虽然我们单独放在一个进程上处理，但是合成时间的长短与内存消耗也会影响最终的成功率
(与修改Dex大小、补丁大小相关)。
</code></pre><p>但是我觉得这两个缺点都不是问题，毕竟热修复不能当做更新来用。。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/02/20/android系统分析/AIDL的梳理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/20/android系统分析/AIDL的梳理/" itemprop="url">AIDL的梳理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-20T18:06:36+08:00">2017-02-20</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>android IPC 不得不提到AIDL，其余广播 bundle ContentProvider以及socket</p>
<p>其中又以AIDL最为关键（在android中就是这样）。</p>
<p>其中又有一个关键字Binder，在我理解看来Binder是一个桥梁。</p>
<p>下面演示下binder，按照android开发艺术探索的指引，生成IBookManager.java文件</p>
<pre><code>/*
 * This file is auto-generated.  DO NOT MODIFY.
 * Original file: E:\\workspace_study\\ZKTestProject\\app\\src\\main\\aidl\\com\\zhaokang\\zktestproject\\IBookManager.aidl
 */
package com.zhaokang.zktestproject;

public interface IBookManager extends android.os.IInterface {
    /**
     * Local-side IPC implementation stub class.
     */
    public static abstract class Stub extends android.os.Binder implements com.zhaokang.zktestproject.IBookManager {
        private static final java.lang.String DESCRIPTOR = &quot;com.zhaokang.zktestproject.IBookManager&quot;;

        /**
         * Construct the stub at attach it to the interface.
         */
        public Stub() {
            this.attachInterface(this, DESCRIPTOR);
        }

        /**
         * Cast an IBinder object into an com.zhaokang.zktestproject.IBookManager interface,
         * generating a proxy if needed.
         */
        public static com.zhaokang.zktestproject.IBookManager asInterface(android.os.IBinder obj) {
            if ((obj == null)) {
                return null;
            }
            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);
            if (((iin != null) &amp;&amp; (iin instanceof com.zhaokang.zktestproject.IBookManager))) {
                return ((com.zhaokang.zktestproject.IBookManager) iin);
            }
            return new com.zhaokang.zktestproject.IBookManager.Stub.Proxy(obj);
        }

        @Override
        public android.os.IBinder asBinder() {
            return this;
        }

        @Override
        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException {
            switch (code) {
                case INTERFACE_TRANSACTION: {
                    reply.writeString(DESCRIPTOR);
                    return true;
                }
                case TRANSACTION_getBookList: {
                    data.enforceInterface(DESCRIPTOR);
                    java.util.List&lt;com.zhaokang.zktestproject.Book&gt; _result = this.getBookList();
                    reply.writeNoException();
                    reply.writeTypedList(_result);
                    return true;
                }
                case TRANSACTION_addBook: {
                    data.enforceInterface(DESCRIPTOR);
                    com.zhaokang.zktestproject.Book _arg0;
                    if ((0 != data.readInt())) {
                        _arg0 = com.zhaokang.zktestproject.Book.CREATOR.createFromParcel(data);
                    } else {
                        _arg0 = null;
                    }
                    this.addBook(_arg0);
                    reply.writeNoException();
                    return true;
                }
            }
            return super.onTransact(code, data, reply, flags);
        }

        private static class Proxy implements com.zhaokang.zktestproject.IBookManager {
            private android.os.IBinder mRemote;

            Proxy(android.os.IBinder remote) {
                mRemote = remote;
            }

            @Override
            public android.os.IBinder asBinder() {
                return mRemote;
            }

            public java.lang.String getInterfaceDescriptor() {
                return DESCRIPTOR;
            }

            @Override
            public java.util.List&lt;com.zhaokang.zktestproject.Book&gt; getBookList() throws android.os.RemoteException {
                android.os.Parcel _data = android.os.Parcel.obtain();
                android.os.Parcel _reply = android.os.Parcel.obtain();
                java.util.List&lt;com.zhaokang.zktestproject.Book&gt; _result;
                try {
                    _data.writeInterfaceToken(DESCRIPTOR);
                    mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0);
                    _reply.readException();
                    _result = _reply.createTypedArrayList(com.zhaokang.zktestproject.Book.CREATOR);
                } finally {
                    _reply.recycle();
                    _data.recycle();
                }
                return _result;
            }

            @Override
            public void addBook(com.zhaokang.zktestproject.Book book) throws android.os.RemoteException {
                android.os.Parcel _data = android.os.Parcel.obtain();
                android.os.Parcel _reply = android.os.Parcel.obtain();
                try {
                    _data.writeInterfaceToken(DESCRIPTOR);
                    if ((book != null)) {
                        _data.writeInt(1);
                        book.writeToParcel(_data, 0);
                    } else {
                        _data.writeInt(0);
                    }
                    mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, 0);
                    _reply.readException();
                } finally {
                    _reply.recycle();
                    _data.recycle();
                }
            }
        }

        static final int TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);
        static final int TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1);
    }

    public java.util.List&lt;com.zhaokang.zktestproject.Book&gt; getBookList() throws android.os.RemoteException;

    public void addBook(com.zhaokang.zktestproject.Book book) throws android.os.RemoteException;
}
</code></pre><hr>
<p>再贴下service的代码<br>    package com.zhaokang.zktestproject;</p>
<pre><code>import android.app.Service;
import android.content.Intent;
import android.os.Binder;
import android.os.IBinder;
import android.os.RemoteCallbackList;
import android.os.RemoteException;
import android.os.SystemClock;
import android.util.Log;

import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.atomic.AtomicBoolean;

public class BookManagerService extends Service {

    private static final String TAG = &quot;BMS&quot;;

    private AtomicBoolean mIsServiceDestroyed = new AtomicBoolean(false);

    private CopyOnWriteArrayList&lt;Book&gt; mBookList = new CopyOnWriteArrayList&lt;&gt;();

    private RemoteCallbackList&lt;IOnNewBookArrivedListener&gt; mListenerList = new RemoteCallbackList&lt;&gt;();

    private Binder mBinder = new IBookManager.Stub() {

        @Override
        public List&lt;Book&gt; getBookList() throws RemoteException {
//            SystemClock.sleep(5000);
            return mBookList;
        }

        @Override
        public void addBook(Book book) throws RemoteException {
            mBookList.add(book);
        }

        @Override
        public void registerListener(IOnNewBookArrivedListener listener) throws RemoteException {
//            if (!mListenerList.contains(listener)) {
//                mListenerList.add(listener);
//            } else {
//                Log.i(TAG, &quot;already exist&quot;);
//            }
//            Log.i(TAG, &quot;registerListener, size = &quot; + mListenerList.size());
            mListenerList.register(listener);
        }

        @Override
        public void unRegisterListener(IOnNewBookArrivedListener listener) throws RemoteException {
//            if (mListenerList.contains(listener)) {
//                mListenerList.remove(listener);
//                Log.i(TAG, &quot;unRegisterListener success&quot;);
//            } else {
//                Log.i(TAG, &quot;unRegisterListener fail&quot;);
//            }
//            Log.i(TAG, &quot;unRegisterListener, size = &quot; + mListenerList.size());
            mListenerList.unregister(listener);
        }
    };

    @Override
    public void onCreate() {
        super.onCreate();
        mBookList.add(new Book(1, &quot;android&quot;));
        mBookList.add(new Book(2, &quot;ios&quot;));
        new Thread(new ServiceWorker()).start();
    }

    @Override
    public IBinder onBind(Intent intent) {
        return mBinder;
    }

    private void onNewBookArrived(Book book) throws RemoteException {
        mBookList.add(book);
//        Log.i(TAG, &quot;onNewBookArrived notify listeners&quot; + mListenerList.size());
        final int N = mListenerList.beginBroadcast();
        for (int i = 0; i &lt; N; i++) {
            IOnNewBookArrivedListener listener = mListenerList.getBroadcastItem(i);
            Log.d(TAG, &quot;onNewBookArrived notify listener&quot; + listener);
            listener.onNewBookArrived(book);
        }
    }

    private class ServiceWorker implements Runnable {

        @Override
        public void run() {
            while (!mIsServiceDestroyed.get()) {
                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                int bookId = mBookList.size() + 1;
                Book newBook = new Book(bookId, &quot;new Book#&quot; + bookId);
                try {
                    onNewBookArrived(newBook);
                } catch (RemoteException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
</code></pre><p>stub就是binder类</p>
<pre><code>DESCRIPTOR是binder类名

asInterface(android.os.IBinder obj)将服务端binder转换成客户端需要的接口类型，如果是同进程，返回stub，如果跨进程返回
proxy。

asBinder 返回binder

onTransact  public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) 
该方法运行在服务端的线程池中。
transact翻译来是处理 当客户端发出ipc请求，最终由该方法处理，根据code来判断调用哪个方法，从data中取出数据，用reply返回数据。
如果该方法返回false，客户端的请求会失败。

Proxy#getBookList java.util.List&lt;com.zhaokang.zktestproject.Book&gt; getBookList() 创建data，reply，和最后的返回list

 if ((book != null)) {
    _data.writeInt(1);
     book.writeToParcel(_data, 0);
    } else {
         _data.writeInt(0);
    }
    。。。
 }

如果有参数，就放入data，随后调用服务端的onTransact，同时当前线程挂起，等到onTransact返回reply，随后返回reply的数据

注意点

1. 客户端发起请求后线程会挂起，为了防止影响ui线程，建议在子线程中发起请求。（客户端服务端道理相同）
2. onTransact运行在线程池中，所以必须用同步的方式去执行。
</code></pre><hr>
<pre><code>以上是binder的分析

aidl完全是根据binder的封装的

需要注意的点，两端如果某方法耗时，那么调用方需要在子线程中调用

解绑接口时要使用RemoteCallbckList，由该类来维护所有的进程间接口

服务进程意外断掉的情况，在serviceDisconnected中重连服务，或者给binder设置死亡代理DeathRecipient，重连服务，
我感觉前者比较好用

aidl权限验证：在onBind方法中permission验证，在onTransact方法中permission验证，其余还有包名验证等。
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/02/08/android系统分析/android面试分享/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/08/android系统分析/android面试分享/" itemprop="url">android面试分享</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-08T17:31:32+08:00">2017-02-08</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>首先感谢各个公司给了我面试的机会
</code></pre><p>这段时间在看机会，去了几个面试，把面试到的题目和大家分享一下</p>
<h3 id="某AI公司，面试官非常有耐心，人非常好（好想跟他混。。。）"><a href="#某AI公司，面试官非常有耐心，人非常好（好想跟他混。。。）" class="headerlink" title=" 某AI公司，面试官非常有耐心，人非常好（好想跟他混。。。）"></a><font color="af8888"> 某AI公司，面试官非常有耐心，人非常好（好想跟他混。。。）</font></h3><ol>
<li><p>oauth2.0授权的流程<br> 第三方应用去服务商获取app secret<br> （A）用户打开客户端以后，客户端要求用户给予授权—–跳至服务商页面。</p>
<p> （B）如果用户同意，那么登录，根据用户登录信息和app secret，服务商同意给予客户端授权accessToken。</p>
<p> （C）客户端使用上一步获得的授权accessToken，向资源服务器申请获取资源。</p>
<p> （D）资源服务器确认令牌无误，返回该accessToken的相关数据。</p>
</li>
<li><p><a href="http://clunyes.github.io/2017/03/03/java深入学习/jni浅析/">jni调用</a>.</p>
</li>
<li><p>IPC AIDL的简单实现<br>IPC的各种方式 广播 AIDL Messenger bundle ContentProvider以及socket<br> 要理解aidl要首先理解binder<br> Binder是什么：binder连接前台应用和service的桥梁<br> <a href="http://clunyes.github.io/2017/02/20/android系统分析/AIDL的梳理/">具体aidl怎么实现</a>.</p>
</li>
<li><p>tcp长连接</p>
<p> 采用心跳包来keep-alive<br> keep-alive ：一个连接在２小时内没有任何动作，服务器就向客户机发送一个探测报文，对于客户机：</p>
<pre><code>(1)正常运行，并从服务器可达，TCP响应正常，保活定时器复位(再次获得２小时)
(2)客户机崩溃,关闭或者正在重启，TCP无响应，75秒后超时，服务器稍后发送9个探测报文(共计１０个)，间隔都为75秒。TCP都没有响应，认为客户机已经关闭连接
(3)客户机崩溃并重启完成：服务器将收到一个探测响应，这个响应是一个复位，使得服务器终止这个连接。
(4)客户机正常运行，但是服务器不可达，探测无响应，10次探测后无响应，关闭
</code></pre></li>
<li><p>git命令，git rebase</p>
<p> 因为公司的原因一直在用svn，git都是我个人在玩。所以对于这个问题，还是一脸懵逼，看来还是要多学习。</p>
</li>
<li><p>surfaceView的特性</p>
<p> SurfaceView和View最本质的区别在于，surfaceView是在一个新起的单独线程中，可以重新绘制画面（双缓冲绘制）而View必须在UI的主线程中更新画面。</p>
<p> SurfaceView控件适合内存耗费大、需要频繁刷新的场景，常用于显示游戏、动画、视频等。</p>
<p> 两个重要方法lockCanvas；unlockCanvasAndPost<br> ps什么叫双缓冲：SurfaceView内部会有两块Buffer。调用lockCanvas之后，便可以在bufferA上绘图了。绘完之后，调用unlockCanvasAndPost将bufferA显示再屏幕上，<br> 随后调用lockCanvas，在bufferB上绘图，调用unlockCanvasAndPost将bufferB显示在屏幕上。repeat。</p>
</li>
<li><p>httpdns</p>
<p> httpdns和dns有什么差别<br> httpdns基于http协议<br> httpdns：httpdns使用HTTP协议进行域名解析，代替现有基于udp的dns协议</p>
<p> httpdns优势：防劫持，精准调度，使用场景也是app居多。<br> 下一个问题，怎么用httpdns–阿里云就提供了，但是要按流量收费。</p>
</li>
<li><p>art dalvik的区别</p>
<p> art采用预加载机制，在apk安装时就编译完成，占用空间更多一些。dalvik是动态编译，每次启动都要编译。<br> gc方面，dalvik是同步的，art是部分异步。</p>
</li>
<li><p>事件分发</p>
<p> 三个关键方法：dispatchTouchEvent 是否消耗当前事件<br> onInterceptTouchEvent 是否拦截当前事件<br> onTouchEvent 是否消耗当前事件</p>
<p> 那么这三个方法有啥关系呢</p>
<pre><code>public  boolean dispatchTouchEvent(MotionEvent ev){
    boolean consume = false;
    if(onInterceptTouchEvent(ev)){
        consume = onTouchEvent(ev);
    } else{
        consume = child.dispatchTouchEvent(ev);
    }
    return consume;
}
</code></pre><p> 有些要点需要记住，一个事件序列只能被一个view消耗，</p>
<p> 如果一个事件没有view去处理，那么事件会交给activity处理</p>
<p> ViewGroup的onInterceptTouchEvent默认不调用</p>
<p> view没有onInterceptTouchEvent的方法</p>
<p> 事件传递是由activity–window–view。</p>
</li>
<li><p>layout绘制流程</p>
<p>activity attach方法，创建window建立关联。setContentView</p>
<ol>
<li>如果没有DecorView就创建一个（DecorView包含标题栏和内容栏（经大神验证，标题栏不是状态栏statusBar））</li>
<li>将你的xml，添加到decorView的内容栏contentPatent（R.id.content）</li>
<li>activity回调onContentChanged</li>
<li>最后在onResume中调用makeVisible</li>
</ol>
<p>结构就是DecorView–&gt; ViewGroup（DecorView的内容栏）–&gt; 你的View。</p>
<p>说道这里，必须说一下activity window和view的故事</p>
<pre><code>我们知道view是视图，但是android中view不能单独存在，他必须依附于window之上，window就是负责展示view的。
activity负责控制window的行为，同时window的结果都会回调给activity。
那么view和window是怎么bind起来的呢，通过ViewRootImpl，它就是window和view交互的桥梁。
</code></pre></li>
<li><p>jvm</p>
<p>详见 <a href="http://www.jianshu.com/p/54eb60cfa7bd" target="_blank" rel="noopener">http://www.jianshu.com/p/54eb60cfa7bd</a></p>
</li>
<li><p>内存泄漏</p>
<pre><code>推荐一个很好的文章https://medium.com/freenet-engineering/memory-leaks-in-android-identify-treat-and-avoid-d0b1233acc8#.tny5y511b
说明了几种容易泄漏的点，归总也就是一点activity或者fragment中不要有超过本身生命周期的引用，
否则activity（fragment）无法被回收。

1服务不关，2内部类（网络请求的），3匿名类（也是网络请求） 网络请求，退出务必关闭回收或者取消。
异步线程对控件等用弱引用的方式引用

depth是0的就是泄漏的

文章最后给出了一些建议，关于多线程其实rxjava是非常好的解决方案。
</code></pre></li>
</ol>
<h3 id="某宝公司的电话面试"><a href="#某宝公司的电话面试" class="headerlink" title=" 某宝公司的电话面试"></a><font color="af8888"> 某宝公司的电话面试</font></h3><ol>
<li><p>android生命周期介绍</p>
<p> onCreate<br> onRestart activity从不可见状态切换成可见状态<br> onStart activity已经可见了，但是还在后台<br> onResume activity可见了<br> onPause activity还是可见的，但是不能交互了<br> onStop activity不可见<br> onDestroy</p>
<p> onPause和onStop一般一起触发</p>
</li>
<li><p>activity的四种启动模式</p>
<p> 先介绍两个概念task和taskAffinity，</p>
<pre><code>task：翻译过来就是“任务”，是一组相互有关联的 activity 集合，可以理解为 Activity 是在 task 里面活动的。 
task 存在于一个称为 back stack 的数据结构中，也就是说， task 是以栈的形式去管理 activity 的，
所以也叫可以称为“任务栈”。
taskAffinity：官方文档解释是：&quot;The task that the activity has an affinity for.&quot;，
可以翻译为 activity 相关或者亲和的任务，这个参数标识了一个 Activity 所需要的任务栈的名字。
默认情况下，所有Activity所需的任务栈的名字为应用的包名。 taskAffinity 属性主要和 singleTask 
启动模式或者 allowTaskReparenting 属性配对使用。
</code></pre><p> 正常standard启动模式的activity默认会进入应用报名所属的任务栈中</p>
<p> standard 默认 重新创建</p>
<p> singleTop 栈顶复用，如果栈顶就是这个Activity，那么onNewIntent会被调用</p>
<p> singleTask 栈内复用，在第一次启动这个 Activity 时，系统便会创建一个新的任务，taskAffinity 属性是和 singleTask 模式搭配使用的。<br> 。如果再次调用会弹出目标activity之上的其余activity，回调onNewIntent。还有个特殊参数allowTaskReparenting，如果是true，会转移任务栈。</p>
<p> singleInstance 单独占用一个栈，其余与singleTask一致</p>
</li>
<li><p>远程service的调用<br> localService和remoteService,就是上文的ipc</p>
</li>
<li><p>activity和fragment的区别，fragment的优势<br> fragment对比activity更灵活，fragment轻量级，更加易于管理，易于适配手机和平板。</p>
<p> 生命周期如下图：<br> <img src="/2017/02/08/android系统分析/android面试分享/../../../../images/lifecycle.png" alt=""></p>
</li>
<li><p>最满意的模块和其中使用的设计模式<br> 恩。。</p>
</li>
<li><p>https</p>
<p> http + tls/ssl </p>
</li>
</ol>
<h2 id="单独说一下looper-handler"><a href="#单独说一下looper-handler" class="headerlink" title="单独说一下looper handler"></a>单独说一下looper handler</h2><ul>
<li>每一个线程有一个Looper，looper内部有一个mq</li>
<li>handler有它的特性，handler可以在任意线程发送消息，handler发送的消息都会发送到它关联的looper的mq中<br>（handler的创建会关联一个looper，如果不设置默认是当前线程的looper）</li>
<li>looper会轮询自己的mq来处理消息，交给handler的handleMessage去处理。</li>
</ul>
<p>Looper.loop() looper开始工作</p>
<p><a href="http://clunyes.github.io/2017/02/27/java深入学习/javaThread状态/">深入探讨下线程</a>.</p>
<p><a href="http://clunyes.github.io/2017/02/28/java深入学习/java线程池/">java线程池</a>.</p>
<h3 id="某怡科技面试，android负责人技术还行，感觉是对着android开发艺术探索来面的，不过这本书确实经典"><a href="#某怡科技面试，android负责人技术还行，感觉是对着android开发艺术探索来面的，不过这本书确实经典" class="headerlink" title=" 某怡科技面试，android负责人技术还行，感觉是对着android开发艺术探索来面的，不过这本书确实经典"></a><font color="af8888"> 某怡科技面试，android负责人技术还行，</font>感觉是对着android开发艺术探索来面的，不过这本书确实经典</h3><ol>
<li><p>线程池具体实现有哪几种</p>
<p> FixedThreadPool   线程池固定的线程池<br> CachedThreadPool  线程数上限很大，一有任务就会执行，终止并从缓存中移除那些已有 60 秒钟未被使用的线程。<br> 全部闲置时，线程全部停止，此时线程池不占用内存<br> ScheduledThreadPool  核心线程数固定，非核心线程数目不固定，闲置就会回收。适用于执行定时任务，固定周期的任务。<br> SingleThreadExecutor 单个线程的线程池，是同步的</p>
</li>
<li><p>onMeasure参数意义<br> MeasureSpec 32位的值，高2位是SpecMode，低30位是SpecSize</p>
<p> SpecMode为</p>
<p> UNSPECIFIED 父容器不对view有任何限制</p>
<p> EXACTLY 父容器已经检测出view所需要的具体大小，最终大小就是specSize</p>
<p> AT_MOLT 父容器指定了一个可用的specSize，view的大小不能超过这个specSize</p>
<p> LayoutParam和父容器一起决定MeasureSpec:</p>
<p> layoutParam.match_parent 大小就是窗口大小</p>
<p> layoutParam.wrap_content 大小不定，不能超过窗口大小</p>
<p> 100dp固定大小：为layoutParam指定的大小 </p>
<p> 以上为基础知识</p>
<p> 子元素measureSpec创建和父容器measureSpec和子元素本身的LayoutParam，还有子元素的margin padding有关系</p>
<p> 在写自定义view时，自身大小为具体size,view的specMode都是EXACTLY为childSize，如果是match_content 那么不论是EXACTLY还是AT_MOST都是parentSize，<br> 如果要自身大小为wrap_content，则需要重写onMeasure方法，因为在wrap_content时，view的specMode都是AT_MOST，即会填满父控件，这不是我们想要得效果<br> 如何重写，在onMeasure中判断AT_MOST，将宽高用默认宽高代替。</p>
</li>
<li><p>自定义绘图，旋转</p>
<p> 采用matrix.setRotate的方式，matrix bitmap的关系？</p>
</li>
<li><p>图片3级缓存</p>
<p> 网络缓存, 不优先加载, 速度慢,浪费流量<br> 本地缓存, 次优先加载, 速度快<br> 内存缓存, 优先加载, 速度最快</p>
</li>
<li><p>activity的启动过程</p>
<p> <a href="http://clunyes.github.io/2017/02/24/android系统分析/activity启动和service启动/">详细说明</a></p>
</li>
<li><p>IntentService<br> service是运行在主线程中的，所以service是不能进行耗时操作的<br> 可以执行耗时的任务的service，内部实现是HandlerThread和handler。HandlerThread是一个有Looper的Thread。<br> 正是由于HandlerThread，IntentService可以进行耗时操作，处理完所有逻辑之后，会自动关闭服务！（这么厉害的东西，之前都没用过）</p>
</li>
<li><p>图片缓存回收的算法    </p>
<pre><code>1. 新数据插入到链表头部；

2. 每当缓存命中（即缓存数据被访问），则将数据移到链表头部；

3. 当链表满的时候，将链表尾部的数据丢弃。
</code></pre><p> LRU，最近最少使用算法<br> LruCache是由LinkedHashMap来实现的，同步实现（因为是不同线程调用的）。</p>
<p> 图片缓存的是drawable。</p>
</li>
<li><p>并发场景，争夺资源</p>
<p> <a href="http://clunyes.github.io/2017/03/01/java深入学习/java线程安全/">synchronized</a></p>
</li>
</ol>
<h3 id="扩展问题"><a href="#扩展问题" class="headerlink" title=" 扩展问题"></a><font color="af8888"> 扩展问题</font></h3><ol>
<li><p>数据结构有哪些</p>
<pre><code>1. 逻辑结构分为:集合结构；线性结构；树形结构；图形结构
2. 物理（计算机存储）结构：顺序存储结构，数组；链式存储结构，链表
</code></pre><p>数组 String[] 包括列表</p>
<p>链表 LinkedList</p>
<p>栈 activity task 就是一个栈，先进后出</p>
<p>队列  基本上，一个队列就是一个先入先出（FIFO）的数据结构</p>
<p>树</p>
<p>图</p>
</li>
<li><p>java  copyOnWrite思路，<br> <a href="http://clunyes.github.io/2017/02/28/java深入学习/java集合理解/">各种集合类的实现</a></p>
</li>
<li><p><a href="http://clunyes.github.io/2017/02/22/android热修复原理/">android 热修复原理</a></p>
</li>
<li><p>android保活</p>
<ol>
<li><p>不同app利用广播相互唤醒</p>
</li>
<li><p>开启前台服务，不显示notification–这种方式还是会被杀死的</p>
</li>
<li><p>如果够牛逼，进入系统的白名单</p>
</li>
<li><p>一个像素的activity</p>
</li>
<li><p>JobScheduler（有待验证怎么使用的）</p>
<p>进程回收机制：系统内存不足的情况下android会开始杀进程，所使用的机制就是Low Memory Killer。</p>
<p>oom_adj值越低越不会被杀死</p>
<p>app退到后台时，其所有的进程优先级都会降低。但是UI进程是降低最为明显的，因为它占用的内存资源最多，<br>系统内存不足的时候肯定优先杀这些占用内存高的进程来腾出资源。所以，为了尽量避免后台UI进程被杀，<br>需要尽可能的释放一些不用的资源，尤其是图片、音视频之类的。</p>
<p>目前来讲，app进入到后台后，如果资源紧张肯定会被kill。</p>
</li>
</ol>
</li>
<li><p>生产者消费者模式</p>
</li>
<li><p>android优化</p>
<ol>
<li>内存泄漏方面</li>
<li>ui视图绘制慢导致卡顿</li>
<li>严苛模式</li>
<li>启动优化–不必要在application中初始化的代码，放到ui初始化完成后。</li>
</ol>
</li>
<li><p>socket的基本流程<br> <img src="/2017/02/08/android系统分析/android面试分享/../../../../images/socket主流程.png" alt=""></p>
</li>
</ol>
<h3 id="唯X科技面试，有一句说一句，面试官是架构师技术非常不错，人很谦和，"><a href="#唯X科技面试，有一句说一句，面试官是架构师技术非常不错，人很谦和，" class="headerlink" title=" 唯X科技面试，有一句说一句，面试官是架构师技术非常不错，人很谦和，"></a><font color="af8888"> 唯X科技面试，</font>有一句说一句，面试官是架构师技术非常不错，人很谦和，</h3><p>面试官表示我还是个中级。哎，慢慢面吧。</p>
<ol>
<li><p>android ndk 开发</p>
</li>
<li><p>对于android framework的理解</p>
</li>
<li><p>源码要自己敲一遍，理解更加深刻</p>
</li>
<li><p>app启动时间优化 adb shell am start -W cn.mynewclouedeu/cn.mynewclouedeu.ui.activity.ActivityGuide<br>查出启动时间，application初始化使用线程操作。</p>
</li>
<li><p>java与模式，理解低耦合高内聚</p>
</li>
<li><p>动态注册广播比静态注册广播先收到广播</p>
</li>
<li><p>图片压缩，高清晰度，仿微信</p>
</li>
<li><p>aop 面向切面编程</p>
</li>
<li><p>增量更新</p>
</li>
<li><p>注解的理解</p>
</li>
</ol>
<p>这道问题非常考验功力，慢慢修炼。</p>
<h3 id="X联动力面试，面试流程比较奇葩的，提了个需求问行不行"><a href="#X联动力面试，面试流程比较奇葩的，提了个需求问行不行" class="headerlink" title=" X联动力面试，面试流程比较奇葩的，提了个需求问行不行"></a><font color="af8888"> X联动力面试，</font>面试流程比较奇葩的，提了个需求问行不行</h3><ol>
<li><p>需要要和硬件打交道（jni hal你都得会）</p>
</li>
<li><p>自己公司有自己的视频流协议（视频流的协议，通信协议你得熟悉）</p>
</li>
<li><p>要做android app开发（app相关你也得过关）</p>
</li>
</ol>
<p>要求还是挺高的，如果去做的话对于我这样的工程师估计够呛。</p>
<p>顺利的面试我就不发了，目标还是定在大厂，不是大厂也得是大牛领导，实在是不想再去坑爹公司。   </p>
<p>又发现了一个大牛的面经： <a href="http://www.jianshu.com/p/dea7c3555b3c" target="_blank" rel="noopener">http://www.jianshu.com/p/dea7c3555b3c</a>    ，不得不说基础很重要。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/01/22/rxjava/rxjava转换操作符/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/22/rxjava/rxjava转换操作符/" itemprop="url">rxjava转换操作符</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-22T14:42:24+08:00">2017-01-22</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="转换操作符"><a href="#转换操作符" class="headerlink" title="转换操作符"></a>转换操作符</h2><h3 id="buffer操作符"><a href="#buffer操作符" class="headerlink" title="buffer操作符"></a>buffer操作符</h3><p>buffer操作符周期性地收集源Observable产生的结果到列表中，并把这个列表提交给订阅者，<br>订阅者处理后，清空buffer列表，同时接收下一次收集的结果并提交给订阅者，周而复始。</p>
<h3 id="flatMap操作符"><a href="#flatMap操作符" class="headerlink" title="flatMap操作符"></a>flatMap操作符</h3><p>flatMap操作符是把Observable产生的结果转换成多个Observable，然后把这多个Observable“扁平化”成一个Observable，并依次提交产生的结果给订阅者。</p>
<h3 id="concatMap操作符"><a href="#concatMap操作符" class="headerlink" title="concatMap操作符"></a>concatMap操作符</h3><p>cancatMap操作符与flatMap操作符类似，都是把Observable产生的结果转换成多个Observable，然后把这多个Observable“扁平化”成一个Observable，并依次提交产生的结果给订阅者。<br>cancat是有顺序的。</p>
<p>### </p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2017/01/21/rxjava/rxjava创建操作符/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/21/rxjava/rxjava创建操作符/" itemprop="url">rxjava操作符</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-21T09:42:17+08:00">2017-01-21</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://blog.csdn.net/job_hesc/article/details/45798307" target="_blank" rel="noopener">操作符这里讲解的很仔细</a></p>
<p>RxJava的强大之处，在于它提供了非常丰富且功能强悍的操作符，通过使用和组合这些操作符，你几乎能完成所有你想要完成的任务</p>
<ul>
<li>(Observable的创建操作符)，比如：Observable.create()、Observable.just()、Observable.from()等等；</li>
<li>(Observable的转换操作符)，比如：observable.map()、observable.flatMap()、observable.buffer()等等；</li>
<li>(Observable的过滤操作符)，比如：observable.filter()、observable.sample()、observable.take()等等；</li>
<li>(Observable的组合操作符)，比如：observable.join()、observable.merge()、observable.combineLatest()等等；</li>
<li>(Observable的错误处理操作符)，比如:observable.onErrorResumeNext()、observable.retry()等等；</li>
<li>(Observable的功能性操作符)，比如：observable.subscribeOn()、observable.observeOn()、observable.delay()等等；</li>
<li>(Observable的条件操作符)，比如：observable.amb()、observable.contains()、observable.skipUntil()等等；</li>
<li>(Observable数学运算及聚合操作符)，比如：observable.count()、observable.reduce()、observable.concat()等等；</li>
<li>其他如observable.toList()、observable.connect()、observable.publish()等等；</li>
</ul>
<h2 id="创建操作符"><a href="#创建操作符" class="headerlink" title="创建操作符"></a>创建操作符</h2><ul>
<li>常用的创建操作符还是： create from timer interval（像range just defer真是没用过）<h3 id="create操作符"><a href="#create操作符" class="headerlink" title="create操作符"></a>create操作符</h3></li>
</ul>
<p>create操作符是所有创建型操作符的“根”，也就是说其他创建型操作符最后都是通过create操作符来创建Observable的</p>
<h3 id="from操作符"><a href="#from操作符" class="headerlink" title="from操作符"></a>from操作符</h3><p>from操作符是把其他类型的对象和数据类型转化成Observable</p>
<h3 id="just操作符"><a href="#just操作符" class="headerlink" title="just操作符"></a>just操作符</h3><p>just操作符也是把其他类型的对象和数据类型转化成Observable，它和from操作符很像，只是方法的参数有所差别</p>
<h3 id="defer操作符"><a href="#defer操作符" class="headerlink" title="defer操作符"></a>defer操作符</h3><p>defer操作符是直到有订阅者订阅时，才通过Observable的工厂方法创建Observable并执行，defer操作符能够保证Observable的状态是最新的</p>
<h3 id="timer操作符"><a href="#timer操作符" class="headerlink" title="timer操作符"></a>timer操作符</h3><p>timer操作符是创建一串连续的数字，产生这些数字的时间间隔是一定的</p>
<h3 id="interval操作符"><a href="#interval操作符" class="headerlink" title="interval操作符"></a>interval操作符</h3><p>interval操作符是每隔一段时间就产生一个数字，这些数字从0开始，一次递增1直至无穷大；interval操作符的实现效果跟上面的timer操作符的第二种情形一样</p>
<h3 id="range操作符"><a href="#range操作符" class="headerlink" title="range操作符"></a>range操作符</h3><p>range操作符是创建一组在从n开始，个数为m的连续数字，比如range(3,10)，就是创建3、4、5…12的一组数字</p>
<h3 id="repeat-repeatWhen操作符"><a href="#repeat-repeatWhen操作符" class="headerlink" title="repeat/repeatWhen操作符"></a>repeat/repeatWhen操作符</h3><p>repeat操作符是对某一个Observable，重复产生多次结果</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2016/12/12/rxjava/rxjava学习-基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/12/rxjava/rxjava学习-基础/" itemprop="url">rxjava学习-基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-12T15:45:40+08:00">2016-12-12</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##Rxjava 使用笔记<br>最近使用新的框架进行开发，其中最为困惑的就是rxjava，确实入门比较难。<br>经过反复的更改，最终改名rxjava学习-基础，确实需要仔细理解。</p>
<p>###1.20<br>今天终于把2.0项目上线了，那么就系统学习下rxjava，<a href="https://github.com/yuxingxin/RxJava-Essentials-CN" target="_blank" rel="noopener">学习资料在这里</a><br>我直接贴过来了，下面的介绍说的很明白</p>
<ul>
<li>响应式编程是一种基于异步数据流概念的编程模式。数据流就像一条河：它可以被观测，被过滤，被操作，或者为新的消费者与另外一条流合并为一条新的流。</li>
<li>响应式编程的一个关键概念是事件。事件可以被等待，可以触发过程，也可以触发其它事件。事件是唯一的以合适的方式将我们的现实世界映射到我们的软件中：<br>如果屋里太热了我们就打开一扇窗户。同样的，当我们更改电子表（变化的传播）中的一些数值时，我们需要更新整个表格或者我们的机器人碰到墙时会转弯（响应事件）。</li>
<li>今天，响应式编程最通用的一个场景是UI：我们的移动App必须做出对网络调用、用户触摸输入和系统弹框的响应。在这个世界上，软件之所以是事件驱动并响应的是因为现实生活也是如此。</li>
</ul>
<p>rx特点</p>
<ol>
<li>一致性</li>
<li>可扩展：这个在编码过程中特别有感觉。只要思路够清晰，一句话就能把业务处理完，不管同步异步都没问题。</li>
<li>陈述式</li>
<li>可组合</li>
<li>可转化</li>
</ol>
<p>rx的两个最核心的接口<br>IObserver 和 IObservable，所有的链式都衍生自这两个接口。代码如下：</p>
<pre><code class="android">//Defines a provider for push-based notification.
public interface IObservable&lt;out T&gt; 
{
//Notifies the provider that an observer is to receive notifications.
IDisposable Subscribe(IObserver&lt;T&gt; observer);   
}
</code></pre>
<pre><code class="android">public interface IObserver&lt;in T&gt;
{
//Provides the observer with new data.
void OnNext(T value);
//Notifies the observer that the provider has experienced an error condition.
void OnError(Exception error);
//Notifies the observer that the provider has finished sending push-based notifications.
void OnCompleted();
}
</code></pre>
<p>四种角色</p>
<ul>
<li>Observable</li>
<li>Observer</li>
<li>Subscriber</li>
<li>Subjects</li>
</ul>
<p>Observables和Subjects是两个compose的实体，Observers和Subscribers是两个consume实体。</p>
<p>subject是一个神奇的对象，它可以是一个Observable同时也可以是一个Observer：它作为连接这两个世界的一座桥梁。一个Subject可以订阅一个Observable，<br>就像一个观察者，并且它可以执行新的数据，或者传递它接受到的数据，就像一个Observable。很明显，作为一个Observable，观察者们或者其它Subject都可以订阅它。<br>一旦Subject订阅了Observable，它将会触发Observable开始执行。如果原始的Observable是“冷”的，这将会对订阅一个“热”的Observable变量产生影响。</p>
<p>RxJava提供四种不同的Subject：</p>
<ul>
<li>PublishSubject</li>
<li>BehaviorSubject</li>
<li>ReplaySubject</li>
<li>AsyncSubject</li>
</ul>
<font color="af8888">说实话subject我在开发中没怎么注意到，需要到实战中再理解</font>

<p>BehaviorSubject:<br>简单的说，BehaviorSubject会首先向他的订阅者发送截至订阅前最新的一个数据对象（或初始值）,然后正常发送订阅后的数据流。</p>
<p>ReplaySubject:<br>ReplaySubject会缓存它所订阅的所有数据,向任意一个订阅它的观察者重发。</p>
<p>AsyncSubject<br>当Observable完成时AsyncSubject只会发布最后一个数据给已经订阅的每一个观察者。</p>
<p>(这些subject都带有比较特殊的能力，在特定的业务场景下会有优势)</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2016/12/09/android tip/android-tips/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/09/android tip/android-tips/" itemprop="url">android tips</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-09T15:55:17+08:00">2016-12-09</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2016/12/08/android tip/android-studio使用技巧/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/08/android tip/android-studio使用技巧/" itemprop="url">android studio使用技巧</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-08T14:50:11+08:00">2016-12-08</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="android-studio的使用技巧"><a href="#android-studio的使用技巧" class="headerlink" title="android studio的使用技巧"></a>android studio的使用技巧</h3><p>我也算android studio用了一年了，分享一些小技巧</p>
<ul>
<li>import samples 失败 在设置中HTTP Proxy-&gt;Auto-detect proxy settings，就ok</li>
<li>在文件树中定位当前文件，按那个准心按钮</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2016/12/07/屏幕密度思考/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/07/屏幕密度思考/" itemprop="url">屏幕密度思考</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-07T09:37:08+08:00">2016-12-07</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="像素密度-以及-不同屏幕"><a href="#像素密度-以及-不同屏幕" class="headerlink" title="像素密度 以及 不同屏幕"></a>像素密度 以及 不同屏幕</h2><p>这是android开发和设计都很关心的问题。</p>
<p>我们就从md的文档中学习一下。</p>
<ul>
<li>Pixel density（像素密度）：指的是每inch上的像素数</li>
<li>Screen resolution（屏幕分辨率）：屏幕上总共像素数</li>
<li>屏幕密度dpi也就是像素密度 为简便起见，Android 将所有屏幕密度分组为六种通用密度：<br>低、中、高、超高、超超高和超超超高。</li>
<li><p>Density-independent pixels（密度无关像素 ） (dp)：A dp is equal to one physical pixel on a screen with a density of 160.<br>1dp在像素密度 ，公式px = dp * (dpi / 160)<br>为简化您为多种屏幕设计用户界面的方式，Android 将实际屏幕尺寸和密度的范围 分为：<br>4种通用尺寸：小、正常、 大 和超大<br>6种通用密度</p>
<ol>
<li>ldpi（低）~120dpi</li>
<li>mdpi（中）~160dpi</li>
<li>hdpi（高）~240dpi</li>
<li>xhdpi（超高）~320dpi</li>
<li>xxhdpi（超超高）~480dpi</li>
<li>xxxhdpi（超超超高）~640dpi<br>所以在160dpi的屏幕上，1px = 1dp，同理在320dpi的屏幕上 2px = 1dp</li>
</ol>
</li>
<li><p>那么问题出现了，所谓的6种通用密度对应的是那些屏幕分辨率呢？</p>
</li>
<li><p>通用的尺寸和密度按照基线配置（即正常尺寸和 mdpi（中）密度）排列，所以依次超大对应超高…<br>但是，实际生活中每种通用的尺寸和密度都涵盖一个实际屏幕尺寸和密度范围。<br>例如， 两部都报告正常屏幕尺寸的设备在手动测量时，实际屏幕尺寸和 高宽比可能略有不同。<br>类似地，对于两台报告 hdpi 屏幕密度的设备，其实际像素密度可能略有不同，实际开发中，我们可以<br>忽略掉这种差异。 </p>
</li>
<li><p>在为不同的屏幕尺寸设计 UI 时，您会发现每种设计都需要 最小空间。<br>因此，上述每种通用的屏幕尺寸都关联了系统定义的最低 分辨率。<br>这些最小尺寸以“dp”单位表示 — 在定义布局时应使用相同的单位 — 这样系统无需担心屏幕密度的变化。</p>
</li>
</ul>
<p>超大屏幕至少为 960dp x 720dp  设计应采用1280 x 720<br>大屏幕至少为 640dp x 480dp    设计应采用800 x 480<br>正常屏幕至少为 470dp x 320dp  设计应采用480 x 320<br>小屏幕至少为 426dp x 320dp    设计应采用320 x 240</p>
<p>设计师资源也很有限，针对目前市场上，xxhdpi手机越来越多，而ldpi和mpi基本已经退出市场，兼顾各种dpi的考虑，应该吧320dpi作为基准<br>（1年之后，基准可能就要调到xhdpi，换机速度太快，设计的时候去统计网站看看目前市场上的分辨率分布情况）。</p>
<ul>
<li>xhdpi向下向上都可以兼容（比例不会变的很离谱，你想想，如果你在mdpi上设计的很完美的图，<br>到xxhdpi可能已经小的不像话了，只有原来的1/3了，同理现在不能xxhdpi作为标准）</li>
<li><p>有个问题要请设计师注意，160:240:320:480:640 = 2:3:4:6:8，中间有个3:4，所以以xhdpi为基准时，设计的像素值<br>最好为4的倍数，否则在hdpi上容易出现，小数点的像素，容易造成ui的变形，实在不能做到，那也只能开发这边4舍5入了。</p>
</li>
<li><p>*设计开发无需为屏幕尺寸和 密度的每个组合提供备用资源。系统提供强大的兼容性功能，<br>可处理在任何设备屏幕上渲染应用的大多数工作，前提是您已经使用 可以适当调整大小的技术实现UI。</p>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2016/12/02/android tip/android-代号对应表/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/02/android tip/android-代号对应表/" itemprop="url">android 代号对应表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-02T15:01:01+08:00">2016-12-02</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <table>
<thead>
<tr>
<th>平台版本</th>
<th style="text-align:center">API 级别</th>
<th style="text-align:right">VERSION_CODE</th>
<th style="text-align:right">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Android 7.0</td>
<td style="text-align:center">24</td>
<td style="text-align:right">N</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Android 6.0</td>
<td style="text-align:center">23</td>
<td style="text-align:right">M</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Android 5.1</td>
<td style="text-align:center">22</td>
<td style="text-align:right">LOLLIPOP_MR1</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Android 5.0</td>
<td style="text-align:center">21</td>
<td style="text-align:right">LOLLIPOP</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Android 4.4W</td>
<td style="text-align:center">20</td>
<td style="text-align:right">KITKAT_WATCH</td>
<td style="text-align:right">仅限 KitKat for Wearables</td>
</tr>
<tr>
<td>Android 4.4</td>
<td style="text-align:center">19</td>
<td style="text-align:right">KITKAT</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Android 4.3</td>
<td style="text-align:center">18</td>
<td style="text-align:right">JELLY_BEAN_MR2</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Android 4.2、4.2.2</td>
<td style="text-align:center">17</td>
<td style="text-align:right">JELLY_BEAN_MR1</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Android 4.1、4.1.1</td>
<td style="text-align:center">16</td>
<td style="text-align:right">JELLY_BEAN</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Android 4.0.3、4.0.4</td>
<td style="text-align:center">15</td>
<td style="text-align:right">ICE_CREAM_SANDWICH_MR1</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Android 4.0、4.0.1、4.0.2</td>
<td style="text-align:center">14</td>
<td style="text-align:right">ICE_CREAM_SANDWICH</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Android 3.2</td>
<td style="text-align:center">13</td>
<td style="text-align:right">HONEYCOMB_MR2</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Android 3.1.x</td>
<td style="text-align:center">12</td>
<td style="text-align:right">HONEYCOMB_MR1</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Android 3.0.x</td>
<td style="text-align:center">11</td>
<td style="text-align:right">HONEYCOMB</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Android 2.3.4、2.3.3</td>
<td style="text-align:center">10</td>
<td style="text-align:right">GINGERBREAD_MR1</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Android 2.3、2.3.1、2.3.2</td>
<td style="text-align:center">9</td>
<td style="text-align:right">GINGERBREAD</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Android 2.2.x</td>
<td style="text-align:center">8</td>
<td style="text-align:right">FROYO</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Android 2.1.x</td>
<td style="text-align:center">7</td>
<td style="text-align:right">ECLAIR_MR1</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Android 2.0.1</td>
<td style="text-align:center">6</td>
<td style="text-align:right">ECLAIR_0_1</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Android 2.0</td>
<td style="text-align:center">5</td>
<td style="text-align:right">ECLAIR</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Android 1.6</td>
<td style="text-align:center">4</td>
<td style="text-align:right">DONUT</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Android 1.5</td>
<td style="text-align:center">3</td>
<td style="text-align:right">CUPCAKE</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Android 1.1</td>
<td style="text-align:center">2</td>
<td style="text-align:right">BASE_1_1</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Android 1.0</td>
<td style="text-align:center">1</td>
<td style="text-align:right">BASE</td>
<td style="text-align:right"></td>
</tr>
</tbody>
</table>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://clunyes.github.io/2016/09/14/源码阅读/源码阅读计划/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="clunyes">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="clunyes_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/14/源码阅读/源码阅读计划/" itemprop="url">源码阅读计划</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-09-14T16:53:52+08:00">2016-09-14</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>   特开一篇日记来记录的我的源码阅读记录。</p>
<ul>
<li>学习无止境，第一个源码项目定为<a href="http://clunyes.github.io/2016/09/20/volley源码核心/">volley源码</a>.</li>
<li>因为我现在用的网络框架为retrofit+okhttp，第二个源码项目暂定为<a href="http://clunyes.github.io/2016/11/28/OkHttp学习/">okhttp3</a>.</li>
<li>马上会看retrofit（2016.11.28 长时间没更新一方面在开发新的app，一方面沉迷王者荣耀，现在脱坑啦）</li>
<li><p>目前正在对<a href="http://clunyes.github.io/2016/11/29/material-design/">material design</a>阅读，retrofit可能要延后了<br>（2016.12.5）</p>
<p>经过一段时间的学习。特补充一句，看源码，先看接口，再看实现。</p>
<p>看源码，先看接口，再看实现。</p>
<p>看源码，先看接口，再看实现。</p>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="clunyes" />
            
              <p class="site-author-name" itemprop="name">clunyes</p>
              <p class="site-description motion-element" itemprop="description">好想去看dac</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">clunyes</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Pisces</a> v6.0.6</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.6"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.6"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.6"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.6"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.6"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
